<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的ubuntu20的vscode设置</title>
      <link href="/2022/04/10/code_linux/"/>
      <url>/2022/04/10/code_linux/</url>
      
        <content type="html"><![CDATA[<h1 id="我的ubuntu20的vscode设置"><a href="#我的ubuntu20的vscode设置" class="headerlink" title="我的ubuntu20的vscode设置"></a>我的ubuntu20的vscode设置</h1><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;miDebuggerArgs&quot;</span>: <span class="string">&quot;-q -ex quit; wait() &#123; fg &gt;/dev/null; &#125;; /bin/gdb -q --interpreter=mi&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>, <span class="comment">// 配置名称</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,<span class="comment">// 配置类型</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 请求配置类型,launch或者attach</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<span class="comment">// 进行调试程序的路径，程序生成文件.out</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],<span class="comment">// 传递给程序的命令行参数，一般为空</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,<span class="comment">// 调试器是否在目标的入口点停止，</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<span class="comment">// 项目目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,<span class="comment">// 调试时是否显示控制台窗口，一般为true显示控制台</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,<span class="comment">// 指定连接的调试器</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>,<span class="comment">// 任务名</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,<span class="comment">// 指令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;$&#123;file&#125;&quot;</span>, <span class="string">&quot;-std=c++17&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 小提示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT小记</title>
      <link href="/2022/04/06/Qt/"/>
      <url>/2022/04/06/Qt/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>#</p><h1 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h1><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是： </p><p>QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); </p><p>参数 1、信号的发送者 </p><p>参数 2、发送的信号 </p><p>参数 3、信号的接收者 </p><p>参数 4、处理函数（槽函数） </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMetaObject::Connection ret = <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;QWidget::close);</span><br><span class="line">    <span class="comment">//sendr.btn signal.clicked点击 recvier.this widget.close事件 把click信号和槽关联起来</span></span><br></pre></td></tr></table></figure><p>信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的 </p><p>编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。它可以让应用 </p><p>程序编程人员把这些互不了解的对象绑定在一起。</p><p><strong>信号（Signal）</strong> </p><p>信号（Signal）就是在特定情况下被发射的事件，例如 PushButton 最常见的信号就是鼠标 </p><p>单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射 </p><p>的 CurrentIndexChanged() 信号。 </p><p>GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射 </p><p>哪些信号，合理地去响应和处理这些信号就可以了。 </p><p><strong>槽（Slot）</strong> </p><p>就是对信号响应的函数。槽就是一个函数，与一般的 C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><h2 id="Qt-中自定义信号和槽函数"><a href="#Qt-中自定义信号和槽函数" class="headerlink" title="Qt 中自定义信号和槽函数"></a>Qt 中自定义信号和槽函数</h2><p>自定义信号和槽的区别，<strong>信号和槽都为 void 类型</strong>，信号只需要定义，<strong>不需要实</strong> </p><p><strong>现</strong>，而槽函数<strong>既需要定义，也需要实现</strong>，<strong>信号和槽都可以有参数也都可以重载</strong>。emit </p><p>是出发信号的标志，可要可不要。</p><p>注意<strong>信号重载函数指针</strong>指向哪一个函数的问题，对于重载函数的信号连接，要指 </p><p>明到底连接的是哪一个</p><h2 id="信号和槽的扩展"><a href="#信号和槽的扩展" class="headerlink" title="信号和槽的扩展"></a>信号和槽的扩展</h2><p><strong>多个信号可以连接同一个槽函数</strong> </p><p>这个就不用实例了，我们的按钮和窗口上的 xx 都可以关闭窗口。 </p><p><strong>信号和槽的参数必须一一对应。</strong> </p><p>信号的发送什么，槽就接收什么，类型必须一致。但信号的参数个数可以多余槽的参数的个 </p><p>数，但前面相同数量的参数类型必须一一对应。反之则不可以</p><h1 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h1><p>Lambda 函数也叫 Lambda 表达式，是匿名函数，就是没有名字的函数，和传统的函数不一样。Lambda 表达式是 C++11 中引入的新概念，用于定义并创建匿名的函数对象。首先看 </p><p>下 Lambda 表达式的基本结构。</p><p><code>[捕捉列表] (参数) mutable -&gt;返回值类型 &#123;函数体&#125;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]()&#123;</span><br><span class="line"><span class="built_in">qDebug</span>( <span class="string">&quot;Lambda&quot;</span> );</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、 [ ]，标识一个，Lambda 匿名函数的开始，这个必须有，不能省略，函数对象参数是传 递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用到 Lambda 定 义为止 Lambda 所在的作用域范围内可见的局部变量，包括 Lambda 所在类的 <span class="keyword">this</span>。函 数对象参数有以下形式 </span><br><span class="line">    a) 空，没有使用任何的函数对象参数 </span><br><span class="line">    b) =，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 <span class="keyword">this</span> 的传值方 式，相当于编译器给 Lambda 所在地的所有局部变量复制一份给 Lambda 函数 </span><br><span class="line">    c) &amp;，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 <span class="keyword">this</span> 的引用方 式，相当于编译器给 Lambda 所在地的所有局部变量引用一份给 Lambda 函数 </span><br><span class="line">    d) <span class="keyword">this</span>，函数体内可以使用 Lambda 所在内的成员变量 </span><br><span class="line">    e) a,不是字母，而是指具体一个变量 a，那么 Lambda 内拷贝一个 a 使用 </span><br><span class="line">    f) &amp;a，Lambda 内引用 a </span><br><span class="line">    g) a,&amp;b,拷贝 a，引用 b </span><br><span class="line">    h) =，&amp;a，&amp;b，除 ab 引用，其余拷贝 </span><br><span class="line">    i) &amp;，a，b。除 ab 拷贝，其余引用 </span><br><span class="line"><span class="number">2</span>、 函数参数，这个跟常规函数一样。 </span><br><span class="line"><span class="number">3</span>、 mutatble，修改关键字，再对应位置 mutatble 关键字，才能修改函数对象参数。否则报 错。可以有，也可以没有，但有才能修改。lambda 默认是 <span class="keyword">const</span>，也就是不能修改本地 变量。 <span class="number">4</span>、 -&gt;<span class="keyword">return</span>-type 返回值的方式，既然是函数就可能有返回值，那么-&gt;就是有返回值的函 数标志。 </span><br><span class="line"><span class="number">5</span>、 函数体，跟常规函数一样。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;222&quot;</span>,<span class="keyword">this</span>); </span><br><span class="line">QPushButton * btn3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;333&quot;</span>,<span class="keyword">this</span>); </span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">20</span>); </span><br><span class="line">btn3-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">50</span>); </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">connect</span>(btn2,&amp;QPushButton::clicked,<span class="keyword">this</span>,[a]()<span class="keyword">mutable</span>&#123; a += <span class="number">100</span>;<span class="built_in">qDebug</span>()&lt;&lt;a; &#125;); </span><br><span class="line"><span class="built_in">connect</span>(btn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()<span class="keyword">mutable</span>&#123; <span class="built_in">qDebug</span>()&lt;&lt;a; &#125;); <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br></pre></td></tr></table></figure><p>新建两个按钮分别写入以上 Lambda 函数，再连接函数中直接可以写上 Lambda 函数体，消 </p><p>息触发的时候，就直接调用，btn2，中只是将 a 传值，有关键字 mutable 可以在函数中修改 </p><p>a 的值，但不会影响外面的值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret=<span class="number">100</span>;</span><br><span class="line">ret=[&amp;ret]()<span class="keyword">mutable</span>-&gt;<span class="keyword">int</span>&#123;ret*=<span class="number">2</span>;<span class="keyword">return</span> ret;&#125;();</span><br><span class="line">cout&lt;&lt;ret;</span><br><span class="line"><span class="comment">//retx2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">[](<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b,<span class="keyword">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        ret=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=ret;</span><br><span class="line">        cout&lt;&lt;ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(a,b,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//循环20次输出斐波那契数列(后一项是前俩项的和)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>无参按钮调用有参的槽函数 </p>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> 上位机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程基础</title>
      <link href="/2022/04/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Libevent-C-高并发网络编程"><a href="#Libevent-C-高并发网络编程" class="headerlink" title="Libevent C++高并发网络编程"></a>Libevent C++高并发网络编程</h1><h2 id="3-1-课程内容概述"><a href="#3-1-课程内容概述" class="headerlink" title="3.1 课程内容概述"></a>3.1 课程内容概述</h2><ol><li>Libevent源码的跨平台编译和测试</li><li>Libevent原理和网络模型设置</li><li>event事件处理原理和实战</li><li>bufferevent缓冲IO</li><li>bufferevent、zlib实现过滤器中压缩和解压缩</li><li>libevent的http接口实现服务端和客户端</li><li>搭建基于libevent的C++跨平台线程池</li><li>基于libevent和线程池完成FTP服务器开发</li></ol><h1 id="大并发服务器架构学习"><a href="#大并发服务器架构学习" class="headerlink" title="大并发服务器架构学习"></a>大并发服务器架构学习</h1><h2 id="第一章-高性能的服务器架构"><a href="#第一章-高性能的服务器架构" class="headerlink" title="第一章 高性能的服务器架构"></a>第一章 高性能的服务器架构</h2><ul><li>网络I/O + 服务器高性能编程技术 + 数据库</li><li>超出数据库连接数</li><li>超出时限（队列+连接池，缓冲更新，缓冲换页，数据库读写分离进行负载均衡-replication机制）</li></ul><p>服务器性能四大杀手：</p><ul><li>数据拷贝-缓存技术解决</li><li>环境切换-有理性创建线程，单线程还是多线程好，单核服务器（采用状态机编程，效率最佳，减少线程间的切换开销），多线程能够充分发挥多核服务器的性能。</li><li>内存分配-内存池</li><li>锁竞争</li></ul><h2 id="第二章-大型网站架构演变过程"><a href="#第二章-大型网站架构演变过程" class="headerlink" title="第二章 大型网站架构演变过程"></a>第二章 大型网站架构演变过程</h2><ol><li>web动静资源分离</li><li><p>缓存处理</p><ul><li>减少对网站的访问-客户端（浏览器）缓存</li><li>减少对Web应用服务器的请求-前端页面缓存（squid）</li><li>减少对数据库的查询-页面片段缓存ESI（Edge Side Includes）</li><li>减少对文件系统I/O操作-本地数据缓存</li></ul></li><li><p>Web server集群+读写分离（负载均衡）</p><ul><li>前端负载均衡：DNS负载均衡、反向代理、基于NAT的负载均衡技术、LVS、F5硬件负载均衡</li><li>应用服务器负载均衡</li><li>数据库负载均衡</li></ul></li><li>CDN、分布式缓存、分库分表</li><li>多数据中心+分布式存储与计算（技术点DFS分布式文件系统、Key-Value DB、Map/Reduce算法）</li></ol><h2 id="第三章-poll"><a href="#第三章-poll" class="headerlink" title="第三章 poll"></a>第三章 poll</h2><p>Linux下有三种I/O复用模型：select、poll、epoll。</p><h1 id="Linux网络编程基础"><a href="#Linux网络编程基础" class="headerlink" title="Linux网络编程基础"></a>Linux网络编程基础</h1><h2 id="网络基础-综述"><a href="#网络基础-综述" class="headerlink" title="网络基础-综述"></a>网络基础-综述</h2><h3 id="1-协议的概念"><a href="#1-协议的概念" class="headerlink" title="1. 协议的概念"></a>1. <strong>协议的概念</strong></h3><p>TCP协议注重数据的传输，HTTP协议注重数据的解释。</p><h3 id="2-b-s（浏览器-服务端模式）-c-s（客户端-服务端模式）"><a href="#2-b-s（浏览器-服务端模式）-c-s（客户端-服务端模式）" class="headerlink" title="2. b/s（浏览器/服务端模式） c/s（客户端/服务端模式）"></a>2. b/s（浏览器/服务端模式） c/s（客户端/服务端模式）</h3><ul><li><code>C/S模式优点</code>：协议选用灵活，提前对数据进行缓存</li><li>C/S模式缺点：对用户安全构成威胁，开发任务工作量大</li><li><code>B/S模式优点</code>：安全性高，跨平台</li><li>B/S模式缺点：协议选用不灵活，数据加载不缓存</li><li>两者使用场景不同。</li></ul><h3 id="3-分层模型：OSI七层模型-TCP-IP四层模型"><a href="#3-分层模型：OSI七层模型-TCP-IP四层模型" class="headerlink" title="3. 分层模型：OSI七层模型-TCP/IP四层模型"></a>3. <strong>分层模型：OSI七层模型-TCP/IP四层模型</strong></h3><ul><li><code>OSI七层模型</code>: 物理层-&gt;数据链路层-&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）-&gt;会话层-&gt;表示层-&gt;应用层</li><li><code>TCP/IP四层模型</code>：网络接口层———&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）———————-&gt;应用层（FTP协议）</li></ul><h3 id="4-协议格式"><a href="#4-协议格式" class="headerlink" title="4. 协议格式"></a>4. <strong>协议格式</strong></h3><ul><li><code>数据包基本格式</code>：操作系统封装数据和解析数据包；路由器寻路（寻找下一路由节点）的一般思想。</li><li><code>以太网帧格式</code>：|目的地址(6字节)|源地址6字节|类型2字节|数据|CRC校应2字节|</li><li><code>arp数据包格式</code>:|目的地址(6字节)|源地址6字节|帧类型0806|硬件类型-协议类型-硬件地址长度-协议地址长度-op-发送端以太网地址-发送端IP地址目的以太网地址-目的IP地址（28字节ARP请求/应答）|PAD填充18字节|。<code>arp数据报的目的：获取下一跳mac的地址</code>。</li><li><code>IP段格式</code>：在网络层。|4位版本号|4位首部长度|8位服务类型（TOS）|16位总长度（字节数）|</li><li><code>TCP/UDP数据报格式</code></li></ul><h3 id="5-NAT映射-打洞机制"><a href="#5-NAT映射-打洞机制" class="headerlink" title="5. NAT映射 打洞机制"></a>5. <strong>NAT映射 打洞机制</strong></h3><ul><li><code>NAT（Network Address Translation，网络地址转换）</code>，也叫做网络掩蔽或者IP掩蔽。NAT是一种网络地址翻译技术，主要是将内部的私有IP地址（private IP）转换成可以在公网使用的公网IP（public IP）。</li><li>NAT可以同时让多个计算机同时联网，并隐藏其内网IP，因此也增加了内网的网络安全性；此外，NAT对来自外部的数据查看其NAT映射记录，对没有相应记录的数据包进行拒绝，提高了网络安全性。</li><li>打洞机制需要借助公网 <code>IP</code> 实现；</li><li>公-公通信（局域网内IP通信）：直接访问；公-私：NAT映射；私-公：NAT映射；私-私：NAT映射、打洞机制。</li></ul><h3 id="6-套接字socket通信原理概念"><a href="#6-套接字socket通信原理概念" class="headerlink" title="6. 套接字socket通信原理概念"></a>6. <strong>套接字socket通信原理概念</strong></h3><ul><li>IP地址：在网络环境中唯一标识一台主机</li><li>端口号：在主机中唯一标识一个进程</li><li><code>IP地址 + 端口</code>：唯一标识网络通讯中的一个进程，对应一个socket。</li><li><code>socket</code> 成对出现、必须绑定IP+端口、一个文件描述符指向两个缓冲区（一个读一个写）。</li></ul><h4 id="6-1-网络字节序列化"><a href="#6-1-网络字节序列化" class="headerlink" title="6.1 网络字节序列化"></a>6.1 网络字节序列化</h4><ul><li>大端存储：低地址—高位(高地址存低位)</li><li>小端存储：高地址—低位</li></ul><p>TCP/IP协议规定，<code>网络数据流应采用大端字节序</code>。为了使网络程序具有可移植性，使同样的 c 代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p><code>h</code> 标识<code>host</code>， <code>n</code> 表示 <code>network</code>， <code>I</code> 表示 32 位长整数， <code>s</code> 表示 <code>16</code>位短整数。</p><h4 id="6-2-ip地址转换函数"><a href="#6-2-ip地址转换函数" class="headerlink" title="6.2 ip地址转换函数"></a>6.2 ip地址转换函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span> <span class="comment">//字符串ip转换网络字节序;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span> <span class="comment">//网络字节序转换字符串ip;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-3-socketaddr数据结构"><a href="#6-3-socketaddr数据结构" class="headerlink" title="6.3 socketaddr数据结构"></a>6.3 socketaddr数据结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sockaddr_in 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-4-网络套接字函数"><a href="#6-4-网络套接字函数" class="headerlink" title="6.4 网络套接字函数"></a>6.4 网络套接字函数</h4><p>1，创建套接字<code>socket</code>函数.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向创建的socket的文件描述符，失败：返回<span class="number">-1</span>，设置errno。</span><br></pre></td></tr></table></figure><p>2，绑定 <code>ip</code> 和端口号函数 <code>bind</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> cockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd:</span><br><span class="line">    socket 文件描述符</span><br><span class="line">addr:</span><br><span class="line">    构造出IP地址+端口号</span><br><span class="line">addrlen：</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">    成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><h3 id="7-TCP-C-S模型：server-c-client-c"><a href="#7-TCP-C-S模型：server-c-client-c" class="headerlink" title="7. TCP C/S模型：server.c client.c"></a>7. <strong>TCP C/S模型</strong>：server.c client.c</h3>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 408 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="/2022/03/16/Acwing/"/>
      <url>/2022/03/16/Acwing/</url>
      
        <content type="html"><![CDATA[<p> 基础算法</p><p><code>scanf(&quot;%[^\n]&quot;,a);</code> 载入space</p><p>[TOC]</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>1 确定分界点 左 右或者中间<br>2 调整区间 划分成俩部分 大于的和小于的<br>3 递归处理左右俩段<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>求最大值</strong></p><p>例:<br><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/17f1d4f8c7e56194d948cc1b1a6009827b4c7021.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/fe2f9a1aa4f38dbf589b216a96e3d38ba628e7e1.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickfind</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前半部分和快排完全相同</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> a[r];</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出 SL 的长度（分界点 - 左边界 + 1）</span></span><br><span class="line">    <span class="keyword">int</span> SL = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 情况 A</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SL) <span class="keyword">return</span> <span class="built_in">quickfind</span>(l, j, k);</span><br><span class="line">    <span class="comment">// 情况 B</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickfind</span>(j + <span class="number">1</span>, r, k - SL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>主要思想:分治 (双指针算法)</p><p>1.找分界点(中间) mid=(l+r&gt;&gt;1)递归排序左右</p><p>2.归并 把俩个有序的数组合并※</p><p><code>分开后有俩个序列,首先递归将俩个序列各自排序,排序完之后分别有一个指针指向俩个序列的最小值,以第一个序列开始的话,对比俩个序列的值哪一个小,小的就放在新建的res数组里去,然后第一个序列的指针往后移动一位(当俩个数字相同时,随便将一个指针后移).重复,直到一个序列的指针在结尾,那么把另一个序列的数全部放在res后面去即可.</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, left, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = left, l = left, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r &gt; right) || (l &lt;= mid &amp;&amp; nums[l] &lt;= nums[r])) tmp[k++] = nums[l++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = nums[r++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) nums[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chekc</span>(mid))r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度加法 a,b均为非负整数,下同</span></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,j = b.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t += a[i--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t += b[j--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += t%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());<span class="comment">// or reverse(c.begin(),c.end());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">sub</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b)==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b)==<span class="number">-1</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sub</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,j = b.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        t = a[i--] - t - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t-=b[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += (t+<span class="number">10</span>)%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t = t&lt;<span class="number">0</span>? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;*c.<span class="built_in">rbegin</span>()==<span class="string">&#x27;0&#x27;</span>) c.<span class="built_in">erase</span>(c.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="function">string <span class="title">mul</span><span class="params">(string a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span>||b==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t+= (a[i--]-<span class="string">&#x27;0&#x27;</span>)*b;</span><br><span class="line">        c += t%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度除法</span></span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    string c;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += r / b + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) c.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a==b?<span class="number">0</span>:a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>()?<span class="number">1</span>:a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()?<span class="number">-1</span>:a&gt;b?<span class="number">1</span>:<span class="number">-1</span>; <span class="comment">// 这句话和下面注释内容等价</span></span><br><span class="line">    <span class="comment">// if(a==b) return 0;</span></span><br><span class="line">    <span class="comment">// if(a.size()&gt;b.size()) return 1;</span></span><br><span class="line">    <span class="comment">// if(a.size()&lt;b.size()) return -1;</span></span><br><span class="line">    <span class="comment">// return a&gt;b? 1 : -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><strong>一维</strong></p><p><code>前缀和类似于高中的数组,在求数组前n项和,n~m项和的时候,我们可以使用Sn(前n项和的方式去求出我们所需要部分的长度)</code></p><p><code>S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]</code></p><p> <strong>二维</strong></p><p><code>意思同一维 代表求一个面积内某个坐标所对应点的面积</code></p><p><code>S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p><strong>-一维-二维</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/fedd83b37088c87dadc1738166f1f32314690503.png" alt=""></p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>补</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表与邻接表-树与图的存储"><a href="#链表与邻接表-树与图的存储" class="headerlink" title="链表与邻接表:树与图的存储"></a>链表与邻接表:树与图的存储</h2><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320114715.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320153552.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320171935.png" alt=""></p><p>模拟散列表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320180401.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320173908.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL技巧"><a href="#STL技巧" class="headerlink" title="STL技巧"></a>STL技巧</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, string&gt;</span><br><span class="line">    p=<span class="built_in">make_pair</span>(x,xx);<span class="comment">//可以是数字也可以是字符串</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> , pair&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt;&gt;p;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    string a=<span class="string">&quot;lzzzzzz&quot;</span>;</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q=queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    [] <span class="comment">//随机选取</span></span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱(前一个数)和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">    exp:map&lt;string,int&gt;a</span></span><br><span class="line"><span class="function">        a[<span class="string">&quot;lzz&quot;</span>]=</span><span class="number">1</span>; cout&lt;&lt;a[<span class="string">&quot;lzz&quot;</span>] -&gt;<span class="number">1</span></span><br><span class="line">        <span class="built_in">insert</span>()  插入的数是一个<span class="function">pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h3 id="vector遍历"><a href="#vector遍历" class="headerlink" title="vector遍历"></a>vector遍历</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220320191604.png" alt=""></p><h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324031504.png" alt=""></p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220323195446.png" alt=""></p><h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324013225.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324013309.png" alt=""></p><p><strong>第一种解法dfs</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324013057.png" alt=""></p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324030031.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324031557.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220324031715.png" alt=""></p><h2 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220325005124.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// n个链表的链表头  结点的值是多少  每个节点的next值是多少  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220325015944.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//当前链表里的节点对应图里的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h4><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220325022329.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h2 id="二分图：染色法、匈牙利算法"><a href="#二分图：染色法、匈牙利算法" class="headerlink" title="二分图：染色法、匈牙利算法"></a>二分图：染色法、匈牙利算法</h2><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>质数<br>约数<br>欧拉函数<br>快速幂<br>扩展欧几里得算法<br>中国剩余定理<br>高斯消元<br>组合计数<br>容斥原理<br>简单博弈论</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220325163423.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//所有物品个数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//背包容量</span></span><br><span class="line"><span class="keyword">int</span> v[N], w[N];<span class="comment">//v表示体积,w表示价值</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="comment">//表示所有的状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成一维</span></span><br><span class="line"><span class="comment">//f(i)只用到了f(i-1)这层 </span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][n];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">0</span>; k * v[i] &lt;= j; k ++ )</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j]，f[i - <span class="number">1</span>][j - v[i]* k] + w[i] * k);</span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化成二维</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">                    f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化成一维</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h3><p>暴力</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220325204453.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线性DP</span><br><span class="line"></span><br><span class="line">### 数字三角形</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><pre><code>    7  3   88   1   0</code></pre><p>  2   7   4   4<br>4   5   2   6   5</p><p>输入格式<br>第一行包含整数n，表示数字三角形的层数。</p><p>接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p><p>输出格式<br>输出一个整数，表示最大的路径数字和。</p><p>数据范围<br>1 ≤ n ≤ 500,<br>−10000 ≤ 三角形中的整数 ≤ 10000</p><p>输入样例：<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p><p>输出样例：<br>30</p><p>```</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220326165232.png" alt=""></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220326165740.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220327011837.png" alt=""></p><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220327022354.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220327024625.png" alt=""></p><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h1 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h1>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸡学习❀ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础More"><a href="#基础More" class="headerlink" title="基础More"></a>基础More</h1><p><code>size_t : typedef unsigned int</code></p><p>C++的静态转换: b为要转换的内容</p><p><code>int a=static_cast&lt;int 目标类型&gt;(b);</code></p><p>查看变量类型: <code>typeid(变量).name();</code></p><p>格式化输出流:</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/8d5b7f9235bba470a9211975f9add9c31a30009c.jpg" alt=""></p><p>运算优先级:(优先级从上到下)</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/4a20c75c88cde2b4aec77070eaf610af643576aa.jpg" alt=""></p><h3 id="枚举变量"><a href="#枚举变量" class="headerlink" title="枚举变量"></a>枚举变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">xx</span>:</span><span class="keyword">int</span> <span class="comment">//自动递增1,从上往下</span></span><br><span class="line">&#123;</span><br><span class="line">normal,</span><br><span class="line">    high,</span><br><span class="line">    low=xx,</span><br><span class="line">    other, other1=other<span class="comment">//多个情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">xx use_xxn&#123;xx::normal&#125;;</span><br><span class="line">xx use_xxh&#123;xx::high&#125;;</span><br></pre></td></tr></table></figure><p>1.提高代码的可读性和安全性</p><p>2.枚举类型默认int型</p><p>3.枚举类型成员只能是整数类型</p><p>4.枚举类型和其他类型转换需要强制转换</p><h3 id="自定义变量名称"><a href="#自定义变量名称" class="headerlink" title="自定义变量名称"></a>自定义变量名称</h3><p>三种方式:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A Typename <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">typedef</span> Typename A; <span class="comment">//Typename被A替换</span></span><br><span class="line"><span class="keyword">using</span> A=Typename; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p><strong>自定义命名空间:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> yournamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ...</span><br><span class="line">    <span class="function">string</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>变量的声明周期:</strong></p><p>变量生命在代码块结束后死亡.</p><p>全局变量的生命程序运行一直存在</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::xx <span class="comment">//定义后使用双冒号使用</span></span><br></pre></td></tr></table></figure><p><strong>位运算:</strong></p><p>输出二进制文件.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">引用 bitset头文件</span><br><span class="line">std::bitset&lt;要显示的二进制位数&gt;(要显示的变量);</span><br></pre></td></tr></table></figure><p><code>std::boolalpha 可以将流的输出控制为bool类型</code></p><p><strong>字符处理</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_111853.jpg" alt=""></p><p><strong>判断</strong></p><p>C++17语法</p><p>if(int a; check() ) {}</p><p>switch(变量声明 ；条件（）) {}</p><p><code>goto的使用 ： input&#123;代码段&#125;  ... goto input；</code></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的地址连续</p><p>求大小</p><p><code>sizeof(a[])/sizeof(a[0])</code>  or <code>sizeof(数组名/sizeof(类型名))</code></p><p><strong>基于数组的循环</strong></p><p><code>for(变量类型 变量名称 : 数组) &#123;&#125;</code></p><p><code>for(auto 变量名称 : 数组) &#123;&#125;</code></p><h2 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <array></h1><p><code>std::array&lt; 变量类型 , 元素数量&gt; 变量名;</code></p><p><code>exp: std::array&lt;int ,5&gt;stuID; //五个学生的学号</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stuID.size();</span><br><span class="line">stuID.fill(x); //将所有元素都设置为x</span><br><span class="line">stuID.at(1); //返回stu[1]里的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p>array的优点基本都具备 size fill at</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <vector></h1><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_155716.jpg" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_160124.jpg" alt=""></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>c++声明指针需要初始化</p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p><code>int* array[10] 数组里面存了10个指针</code></p><p> <strong>指针详细 {待补充}</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="c内存分配"><a href="#c内存分配" class="headerlink" title="c内存分配"></a>c内存分配</h3><p><code>void*  malloc</code> ： 用法{ }</p><p><code>nullptr 相当于0 （c++17新）</code></p><p><code>void* calloc(size_t count , size_t size);</code> : 为用户分配count*size字节个内存</p><p><code>void* realloc(void* _Block,size_t_size)</code> : 为用户重新分配内存，_Block是用户已经分配好的内存，Size是要求重新分配的大小</p><p><code>void* free(void* _Block)</code> : 释放内存</p><h3 id="c-内存分配"><a href="#c-内存分配" class="headerlink" title="c++内存分配"></a>c++内存分配</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_002002.jpg" alt=""></p><p><strong>释放内存：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>  )  <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[x]) <span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><p><strong>风险</strong></p><ul><li><p>悬挂指针：释放了还在继续使用释放掉的地址</p></li><li><p>内存碎片：频繁申请和释放小块内存会造成内存碎片，原则上可以使用，实际上使得我们无法分配新的内存.但是new和delete的算法会帮助我们尽量规避</p></li></ul><p><strong>复制内存</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220310012821.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_013233.jpg" alt=""></p><h3 id="malloc和new本质区别"><a href="#malloc和new本质区别" class="headerlink" title="malloc和new本质区别"></a>malloc和new本质区别</h3><p>对于普通的数据类型来说malloc和new没什么区别,但是对于类来说,malloc仅仅是分配内存而new除了分配内存以外还会调用构造函数!</p><h3 id="free和delete本质区别"><a href="#free和delete本质区别" class="headerlink" title="free和delete本质区别"></a>free和delete本质区别</h3><p>对于普通的数据类型来说free和delete没有什么区别,但是对于类来说,free仅仅是释放内存空间,而delete不仅释放内存空间,还会调用类的析构函数</p><h3 id="delete和delete-本质区别"><a href="#delete和delete-本质区别" class="headerlink" title="delete和delete[]本质区别"></a>delete和delete[]本质区别</h3><p>对于普通的数据类型来说deletc和delete[]没有什么区别,但是对于类来说,delete仅仅是释放内存空间,且调用第一个元素的析构函数,而delete[]不仅释放内存空间,还会调用每一个元素的析构函数</p><p>对普通数据类型无所谓</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>引用的本质其实就是一种被阉割了的指针，虽然我们取址引用变量得到的是原地址的内存地址，但是引用变量也是占用内存的</code></p><p>引用需要初始化</p><p>提高代码效率，{个人觉得类似于软连接}</p><p>语法： <code>数据类型&amp;变量名称&#123;引用对象的名称&#125;；</code></p><p><code>exp： int a&#123;500&#125;;  int&amp; la&#123;a&#125;;</code> la=500即a=5200.</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_015706.jpg" alt=""></p><p>第一种声明不允许用数组方式访问，第二种可以。</p><p>智能指针不允许指向别的智能指针。具有唯一性。</p><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset();</span><br><span class="line">//reset将会释放std::unique_ptr的内存空间，并且设置为nullptr</span><br><span class="line">get();</span><br><span class="line">//get返回std::unique_ptr的指针</span><br><span class="line">release();</span><br><span class="line">//release返回std::unique_ptr的指针,并且设置为nullptr，但是不会释放占用的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021212.jpg" alt=""></p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021553_edit_658178805450610.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr的复制</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrA&#123;&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrB&#123;std::make_shared&lt;int&gt;(5)&#125;;</span><br><span class="line">ptrA=ptrB;</span><br><span class="line">··························································</span><br><span class="line">//获得计数</span><br><span class="line">long std::shared_ptr.use_count();</span><br><span class="line">.use_count();会返回当前指针共有多少个对象调用</span><br><span class="line"></span><br><span class="line">bool std::shared_ptr.unique();</span><br><span class="line">//unique()会返回以一个bool值，if当前智能指针是唯一拥有该指针的人，返回true</span><br><span class="line"></span><br><span class="line">std::shared_ptr.reset();</span><br><span class="line">//将当前共享指针设置为nullptr，如果是最后一个拥有该指针的对象，释放内存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性</strong></p><p>可以有多个std::shared_ptr指向同一地址，同一地址下只有最后一个std::shared_ptr释放的时候，才会释放其所占用的空间，std::shared_ptr会记录当前有多少个智能指针调用</p><h2 id="C原生字符串"><a href="#C原生字符串" class="headerlink" title="C原生字符串"></a>C原生字符串</h2><p>字符串就是指针，数组</p><p>&lt;! 待补充 —&gt;</p><p><code>wchar_t str[0xff]&#123;L&quot;HEllo&quot;&#125;;</code> 宽字节常量</p><p>（使用utf-16实现UNICODE）</p><p><code>使用UNICODE标准 ： setlocale(LC_ALL,&quot;chs&quot;)</code>  <code>使用wcout输出</code></p><p>std::cout 默认输出char类型的值时会当作字符串进行处理。</p><h2 id="联合体-union"><a href="#联合体-union" class="headerlink" title="联合体 union"></a>联合体 union</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">&#125;</span><br><span class="line">exp:</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> shp;</span><br><span class="line">    <span class="keyword">int</span>   xhp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过union可以创建一个联合体，union中的成员变量共享内存，因此 <strong>union的数据类型大小由其最大的成员变量决定</strong></p><p>union中任意一成员变量发生改变都可能影响别的变量</p><p><strong>匿名联合体、结构体</strong></p><p>顾名思义，没有名字的联合体和结构体</p><p>一般只用一次</p><h2 id="C-字符串string"><a href="#C-字符串string" class="headerlink" title="C++字符串string"></a>C++字符串string</h2><p><code>#include &lt;string&gt;</code></p><p>定义： <code>std::string str&#123;&quot;wow!&quot;&#125;;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; , 要截取的长度&#125;</code> </p><p>exp：<code>string str&#123;&quot;1234&quot;,2&#125;; str=&quot;12&quot;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; ，起始位置 ， 要截取的长度&#125;</code></p><p><code>std::string 变量名称(要复制的个数，&#39;字符&#39;)</code></p><p><strong>连接字符串</strong> <code>std::string str(6,&#39;a&#39;);   str=str+&quot;123;  str=&quot;aaa123&quot;</code></p><p><strong>连接字符串和数字</strong> <code>std::string str = std::to_string(数字)；</code></p><p><strong>字符串连接字符串</strong></p><p>字符串不能直接和别的字符串连接，可以使用临时变量解决(std::string(xx));</p><p>可以 <code>&quot;变量&quot;&quot;变量&quot;  变成&quot;变量变量&quot;</code></p><p>也可以<code>str.append(&quot;你要拼接的内容&quot;)</code> 可以无限加</p><p><strong>字符串连接字符</strong>  直接+’字符’  即可</p><p><strong>截取字符串</strong> <code>.substr(起始位置，要截取的长度); or .substr(起始位置)</code></p><p><strong>长度</strong> <code>std::string.length();</code> 得到长度</p><p><strong>字符串比较</strong> <code>.compare()   比如： str.compare(&quot;abcd&quot;);</code> 大于返回正数，相等等于0；</p><p>扩展： <code>.compare(起始位置,参与比较的长度,被比较的字符串);</code></p><p><strong>字符串搜索</strong>  </p><p><code>.find()</code> 用来搜素字符串的内容,并返回内容所在的位置,当返回值是<code>std::string::npos</code>表示未找到</p><p><code>.find(要搜索的内容 , 开始搜索的位置)</code></p><p><code>.find(要搜索的内容,开始搜素的位置,要纳入的字符串长度[注:是搜索内容的字符串])</code></p><p><code>.rfind()</code> 用法和<code>find</code>一样,从字符串尾部<strong>倒叙搜索</strong></p><p><strong>插入字符串</strong></p><p><code>.insert()</code> 可以在一个string字符串的指定位置插入另一个字符串</p><p><code>.insert(要插入的位置 , 要插入的字符串)</code></p><p><code>.insert(要插入的位置,要插入的字符个数,要插入的字符)</code> exp:id.insert(3,6,’x’);</p><p><code>.insert(要插入的位置,要插入的字符串,要插入的字符串的起始位置,要插入的大小)</code></p><p><code>.insert(要插入的位置,要插入的字符串,要插入的大小)</code></p><p><strong>替换字符串</strong></p><p><code>.replace</code> 可以替换string字符串中的内容</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;)</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,&#39;字符&#39;)</code>对单字符</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,替换后内容节选长度[此处是替换的字符串的])</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;,替换后的起始位置,替换后内容的节选长度</code></p><p><strong>删除字符串</strong></p><p><code>`.erase()</code> 删除字符串中的内容</p><p><code>.erase(要删除的起始位置,要删除的起始长度)</code></p><p><code>.erase(要删除的起始位置)</code> exp: 从起始位置删除所有的内容</p><p><code>str.clear();</code></p><h3 id="指针数组字符串内存学习"><a href="#指针数组字符串内存学习" class="headerlink" title="指针数组字符串内存学习"></a>指针数组字符串内存学习</h3><p>{待补充}</p><p><strong>想得到放字符串这段内存的区域</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220311_164550.jpg" alt=""></p><p>不能修改!</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>exp：输入中文英文等字符串，正确返回字符个数</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012145.jpg" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012436.jpg" alt=""></p><p>待补充</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>指针参数</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_025458.jpg" alt=""></p><p><strong>数组参数</strong></p><p>建议用数组方式引用</p><p><strong>引用参数</strong></p><p>指针可以传入nullptr，而引用不可以</p><p><strong>默认实参</strong></p><p>exp： <code>void func(int a,int&amp; b,int* c,bool x=true)</code></p><p>此时用户根据需要调用func时x可写可不写，不写默认是true</p><p>！<strong>默认实参只能放在最后</strong> 引用定义的时候不能瞎指</p><p><strong>不定量参数</strong></p><p><code>mian（int argc,char** argc）&#123;&#125;</code> C语言也常用</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_224012_edit_807927517925156.jpg" alt=""></p><p><strong>函数返回：返回指针和引用</strong></p><p>{知识很多 待补充}</p><p>比如返回结构体 ，返回指针，返回引用，传递引用参数时的类型转换</p><p>数组的引用：</p><p>exp： <code>int a[100]  int(&amp;b)[100]=a</code></p><p>传递数组引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> (&amp;array)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数：右值引用"><a href="#函数参数：右值引用" class="headerlink" title="函数参数：右值引用"></a>函数参数：右值引用</h2><p>ps：函数使用引用会节约内存消耗</p><p>左值就是一般左边定义的东西有明确的内存空间 可以读取写入，右值是存放在临时空间内</p><p>exp：<code>*(a+1)=2</code>  此事a+1仍然是一个右值</p><p><code>int&amp;&amp;</code> 右值引用 exp:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; e = <span class="number">100</span>+<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123; std::cout&lt;&lt;a; &#125;</span><br><span class="line"><span class="built_in">Add</span>(e+<span class="number">320</span>+<span class="number">329</span>);</span><br></pre></td></tr></table></figure><p>设计字符串类的时候会感受到…….</p><p>exp: 创建一个临时的角色信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">int</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role <span class="title">createmonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(Role&amp;&amp; rl)</span><span class="comment">//没有分配内存空间却达到了同样的效果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;rl.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220313_022431_edit_817161374477392.jpg" alt=""></p><h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><p>loading</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>可以指向特定类型函数的指针</p><p>函数返回类型 (*函数指针变量名)(参数类型 参数名称, ……参数类型 参数名称);</p><p><strong>转类型</strong> <code>char (*myadd)(int,int)=(char (*)(int,int)Add);</code></p><p>强转太长了怎么办: </p><p><code>typedef函数返回类型 (*函数指针变量名)(参数类型 参数名称,....参数类型 参数名称);</code></p><p>也可以: <code>using pfadd=char (*)(int,int);</code></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>C++有，c语言需要自己实现，不自带此功能</p><p>尽管函数名称相同,但是在我们调用函数时,通过函数参数的不同,编译器还是能够确定我们调用的是哪一个函数,因此程序能够准确的编译</p><p>！ 是参数的不同可以确定是哪个函数。 </p><p>但是编译器无法单纯通过返回值来确定你要返回的函数,参数要不同!</p><p>exp: <code>float ave()    和    int ave()</code>   无法重载</p><p>exp: 同样的函数,用指针和数组写法不能重载,引用也不行</p><p>Tips:为什么俩个函数,有一个int&amp; 一个float ,我定义了char变量去调用,强转为(int)x型,去调用函数却仍然是float函数,因为<strong>强转只是声明了一个临时的变量,而引用需要已经定义的(真实存在的)变量</strong></p><p>同样的函数,一个int 一个const int也不行(会出现歧义)</p><p>但是一个是int的引用int&amp;  一个是 const int&amp; 常量引用,那就可以重载</p><p>函数重载的时候不可以设置默认参数</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>除了类型不同外,函数的运算逻辑都一样,这样的函数我们就可以利用函数模板技术来生成对应的函数.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span><span class="comment">//ave求平均值的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于int ave(int a,int b)</span></span><br><span class="line"><span class="keyword">char</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于char ave(cahr a,char b)</span></span><br><span class="line">exp:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b,type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type1 a;<span class="comment">//可以定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以指定一个函数模板</span></span><br><span class="line">exp： ave&lt;<span class="keyword">int</span>&gt;(<span class="number">192.0f</span>,<span class="number">159.3f</span>); <span class="comment">// 执行int ave</span></span><br></pre></td></tr></table></figure><h3 id="函数模板和重载"><a href="#函数模板和重载" class="headerlink" title="函数模板和重载"></a>函数模板和重载</h3><p>函数模板的例外处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">float</span> <span class="title">ave</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b<span class="number">-100.0f</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">我们可以利用<span class="keyword">template</span>&lt;&gt;定义一种函数模板的例外情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数重载优先于函数模板,但是函数模板的例外情况要优先于函数重载</strong></p><p>函数模板的重载 函数模板的重载也是通过参数来区分</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="推断函数模板返回类型-多不同类型"><a href="#推断函数模板返回类型-多不同类型" class="headerlink" title="推断函数模板返回类型(多不同类型)"></a>推断函数模板返回类型(多不同类型)</h3><p>返回值,传入参数都不同</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时调用的时候可以 ave&lt;int,int&gt;();类似于这样强行更改类型</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">2</span>;</span><br><span class="line">M</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">bigger&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line">bigger&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//### 如何更加智能的推断-&gt; (c++14后)</span></span><br><span class="line">temp1ate &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以利用auto来推断返回值的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ab?a:b;)</span><br><span class="line">&#125;</span><br><span class="line">注*<span class="keyword">auto</span>做返回类型推断是在C++<span class="number">14</span>之后引入的</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b-&gt;<span class="keyword">decltype</span>(a&gt;b?a:b)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) bigger(type1 a,type2 b) <span class="comment">//decltype(auto)可以通过引用更改值</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//decltype(auto)为C++14后的写法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><h3 id="函数模板参数"><a href="#函数模板参数" class="headerlink" title="函数模板参数"></a>函数模板参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充 很多</span><br></pre></td></tr></table></figure><h3 id="函数模板本质"><a href="#函数模板本质" class="headerlink" title="函数模板本质"></a>函数模板本质</h3><p>待补充</p><h2 id="auto-and-decltype"><a href="#auto-and-decltype" class="headerlink" title="auto and decltype"></a>auto and decltype</h2><p>c++11之后出现</p><p>auto可以声明一个变量,让编译器根据变量的值来推断变量的类型</p><p>例如<br><code>auto a&#123;123&#125;;</code> 相当于<code>`int a&#123;123;</code> `<br>利用auto的这一特性我们可以利用auto来创建一个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">注*以上都并非<span class="keyword">auto</span>的最恰当用法,不管是函数还是变量,都不推荐使用<span class="keyword">auto</span>来声明</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>不能保留<span class="keyword">const</span>属性</span><br><span class="line">比如</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line">c是<span class="keyword">int</span>类型而非<span class="keyword">const</span>类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> 会优先推断为值类型而非引用类型</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; la=a;</span><br><span class="line"><span class="keyword">auto</span> d=a;</span><br><span class="line">d为<span class="keyword">int</span>类型而非<span class="keyword">int</span>&amp;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span>利用函数返回值来确定类型的时候,函数会执行</span><br><span class="line"><span class="keyword">auto</span> x=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//ave(1,2)会执行x的类型依据ave函数的返回类型来确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>会优先把值匹配成值类型而非引用类型,就以本例来说</span><br><span class="line">假设我们希望bigger函数返回的是<span class="keyword">int</span>&amp; 用<span class="keyword">auto</span>声明达不到这样的效果,为了达到这种目的,我们可以使用另外一种技术:  拖尾函数</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span>-&gt;<span class="keyword">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype关键字可以得出一个表达式的类型;</p><p>语法:decltype(表达式)<br><code>int a&#123;&#125;;</code><br><code>unsigned b;</code><br><code>decltype(a-b) x;相当于unsigned x;</code></p><p>如果decltype内的表达式没经历任何运算,那么得出的数据类型同表达式内的数据类型,并且<strong>decltype可以保留const和引用类型</strong> .</p><p>编译器依处理decltype关键字时的原则:</p><p>如果decltype内的表达式经历了运算,那么得出的数据类型是根据运算结果是否有固定的内存地址(左值)来决定的,如果有固定的内存地址则得出的类型为该类型的引用类型,如果没有固定的内存地址,则得出的类型为该结果的类型.</p><p>如果decltype内的表达式是一个函数,那么得出的数据类型是根据函数的返回类型来确定的;(decltype不会执行函数)</p><h2 id="static-only变量-and-inline"><a href="#static-only变量-and-inline" class="headerlink" title="static(only变量) and inline"></a>static(only变量) and inline</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>利用static可以声明一个静态变量    static类型变量名称;<br>例如:<br>static int a;<br>static的变量,如果没有指定初始化的值,那么会初始化为0,无论有没有指定初始值,都只会初始化一次!</p><p>exp: count不会只会在函数被初始化一次,生命周期很长,值会保留</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline int Add(int a,int b){<br>return a+b;<br>}<br>我们可以用inline声明一个内联函数<br>内联函数将会建议编译器把这个函数处理成内联代码以提升性能<br>始终是建议,具体编译器是否采纳,由编译器决定</p><p>[有些过时了]</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h2 id="函数一些理论"><a href="#函数一些理论" class="headerlink" title="函数一些理论"></a>函数一些理论</h2><h3 id="理解定义和声明"><a href="#理解定义和声明" class="headerlink" title="理解定义和声明"></a>理解定义和声明</h3><p>我们写的函数就是函数的定义</p><p>因为函数的定义是我们要告诉计算机具体如何来执行我们的命令,所以这个命令必须是明确的,你不能告诉它同时往东并且往右,这就说明我们编写代码的时候,你不能多次定义一个函数!<br>因此函数的定义只能有一次!<br>但是函数的声明是我们和编译器的对话,在某些特殊的场景下,我们可以多次声明一个函数!<br>虽然编译器觉得我们啰嗦,但是并不影响我们之前的感情。</p><p>声明的本质是与编译器的对话,单纯的声明并不存在内存的分配,只是给编译器一个大体的概念，既然是对话,我们可以多次对话,所以对于同一个事物,我们可以多次声明;<br>而定义的本质是要通过编译器与计算机对话,这就涉及到内存的分配和访问,因此同一事物,不管声明多少次,但是只能有一次定义;<br>变量其实也适用这个规则,我们可以通过关键字extern声明一个变量,而把变量的声明和定义分开;<br>我们写函数的声明的时候,没有写extern关键字,是因为函数的声明本身就是extern的,因此不需要我们手动指出;<br>extern 的作用也是告诉编译器,此处只是一个声明,你去别处找定义,因此extern是针对的全局变量，因为局部变量不存在去别U找的可能性!而函数的声明自带extern属性,因此函数本身也是全局的!<br>例如: <code>extern int a;</code></p><p>函数名是内存地址</p><h3 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h3><p>多个源码共用一个全局变量<br>在头文件中声明多个源文件中要共用的全局变量<br>察<br>比如<br><code>extern int verId;</code><br>至于verld的定义你可以放到任何源文件中,但是不可以放到头文件中,因为这样就违背了乎个事物只能定义一次的原则!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">放在头文件中的第一行,可以防止头文件被多次调用</span><br><span class="line"></span><br><span class="line">#ifndef</span><br><span class="line">#define</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="创建自己的SDK"><a href="#创建自己的SDK" class="headerlink" title="创建自己的SDK"></a>创建自己的SDK</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION <span class="meta-string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">namespace</span> my_sdk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Getversion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤:(vs环境) 做成静态库</p><p>右键属性-&gt;配置类型.静态库 .lib-&gt;右键属性 . 生成-&gt;打开文件夹 库做好了 .lib</p><p>使用时:<br>右键属性-&gt;包含目录 放入自己的lib-&gt;库目录 加入自己的.h目录-&gt; </p><p>几种方法: 1: <code>#pragma comment(lib,&quot;xxx.lib&quot;)</code>  </p><p>2: 右键属性-&gt;链接器-&gt;输入-&gt;附加依赖项(库目录需要有)</p><h3 id="创建项目类型"><a href="#创建项目类型" class="headerlink" title="创建项目类型"></a>创建项目类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 函数调用约定</span><br><span class="line"></span><br><span class="line">函数调用约定是函数调用与被调用者之间的一种协议,这个协议主要规定了以下两个内容:</span><br><span class="line"></span><br><span class="line">`如何传递参数` `如何恢复栈平衡`</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">函数调用约定_cdecl:</span><br><span class="line">__cdecl参数入栈顺序从右到左</span><br><span class="line">堆栈平衡:谁调用谁平衡</span><br><span class="line">正因为__cdecl这种堆栈平衡方式,能够支持不定量参数</span><br><span class="line"></span><br><span class="line">函数调用约定_stdcall</span><br><span class="line">___stdcall参数入栈顺序从右到左次</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">Windows编程中WINAPICA1LBACK都是__stdcall的宏</span><br><span class="line">生成的函数名会加下划线,后面跟@和参数尺寸</span><br><span class="line">int _stdcallave(int a, int b)</span><br><span class="line"></span><br><span class="line">函数调用约定__fastcall</span><br><span class="line">第一个参数通过ecs传递第二个参数通过edx传递</span><br><span class="line">剩余参数入栈顺序从右到左</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">fastcall的函数执行速度比较快</span><br><span class="line"></span><br><span class="line">_thiscall 用作C++中类的访问,我们将在类的底层时讲这种callnaked call是一个不常用的调用约定,一般用于实模式驱动开发</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>套娃&gt;&gt;&gt;</p><p>a调用b,b调用a称为互递归函数</p><p>递归会造成栈溢出</p><p>内联函数不能递归</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="转换单元"><a href="#转换单元" class="headerlink" title="转换单元"></a>转换单元</h3><p>我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include <xxx.h>)合并后,称为一个转换单元;<br>编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象);<br>最后<strong>链接器将各个转换单元的对象文件链接起来,生成我们的目标程序;</strong><br>比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误.</p><h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><p>即我们在编写代码中,C++标准未作规定的行为,称为未定义行为,未定义行为的结果是不确定的,具体在不同的编译器下会有不向的效果; 比如<br><code>c=2*a++ + ++a*6;</code><br>这里先算a++还是先算++a就是一个未定义行为<br>比如:<br><code>int x=-25602;×=x&gt;2;</code><br>x的结果在不同的编译器下是不确定的,因为这也属于未定义行为</p><h3 id="One-Definition-Rule"><a href="#One-Definition-Rule" class="headerlink" title="One Definition Rule"></a>One Definition Rule</h3><p><strong>单一性规则</strong></p><p>ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则;<br>但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C++20)在每个转换单元中都只允许有一个定义;非inline的函数或变量(C++17),在整个程序中,有且仅有一个定义;</p><p>总结: 有多个声明 , 只能有一个定义</p><h3 id="名称的链接属性"><a href="#名称的链接属性" class="headerlink" title="名称的链接属性"></a>名称的链接属性</h3><p>程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的;<br>链接属性分为以下三种:<br>内部链接属性:该名称仅仅在本转换单元中有效<br>外部链接属性:该名称在其他的转换单元中也有效<br>无链接属性:该名称仅仅能够用于该名称的作用域内访问</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A B</span></span><br><span class="line">将标识符A定义为B的别名</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>整数int</span></span><br><span class="line">整数a&#123;&#125;;</span><br><span class="line"></span><br><span class="line">取消定义： <span class="meta">#<span class="meta-keyword">undef</span></span></span><br><span class="line">    </span><br><span class="line">定义复杂表达式的宏：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(X,Y)  X+Y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVE(X,Y)  (X+Y)/2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIGGER(X,Y)  ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">AVE</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">BIGGER</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">#可以将一个标识符参数字符串化</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(X) std:cout&lt;&lt;#X <span class="comment">//字符串</span></span></span><br><span class="line"><span class="built_in">SHOW</span>(<span class="number">1234f</span>g);=&gt;std:cout&lt;&lt;<span class="string">&quot;12345fg&quot;</span></span><br><span class="line">##可以连接两个标识符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1(X,Y) void X##Y()&#123;std:cout&lt;&lt;#Y;&#125; <span class="comment">//连接字符串</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用#define 的方式定义常量并不安全.</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>有时候为了方便管理,把相关的函数,变量,结构体等会附加到一个命名空间中<br><code>namespace t  &#123;int value;&#125;</code><br>访问这个命名空间的变量<br><code>t:value</code></p><p>所有具有链接属性的对象,只要没有定义命名空间,就默认定义在<code>全局命名空间</code>中,全局命名空间中成员的访问不用显示的指定,当局部名称覆盖了全局名称时才需要显式的指定全局命名空间;<br><code>int a;  ::a=250</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局命名空间的扩展</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> weight &#123;<span class="number">1980</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> height&#123;<span class="number">1080</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">第二个htd属于对htd命名空间的扩展,weight和height同属一个命名空间</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间拓展</span></span><br><span class="line"><span class="function"><span class="keyword">namespace</span> htd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> htd:<span class="built_in">sendSms</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> hack</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> htd::hack::<span class="built_in">hackServer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">htd::sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未命名空间</span></span><br><span class="line">不给命名空间指定名称,将会声明一个未命名的命名空间</span><br><span class="line"><span class="keyword">namespace</span> &#123;&#125;</span><br><span class="line">未命名的命名空间中声明的内容一律为内部链接属性,包括用<span class="keyword">extern</span>声明的内容,未命名的命名空间仅仅在本转换单元中有效</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的别名</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer=htd::hack;</span><br><span class="line">hSever:<span class="built_in">hackServer</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预处理逻辑指令"><a href="#预处理逻辑指令" class="headerlink" title="预处理逻辑指令"></a>预处理逻辑指令</h2><p><code>#ifndef    #if    #elif</code></p><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//标准预定义宏</span><br><span class="line">__func__</span><br><span class="line">编译器支持ISO C99和ISO C++11指定的预定义标识符</span><br><span class="line">函数的名称</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025308.jpg" alt=""></p><p>//下面是微软公司做的宏</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025523.jpg" alt=""></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>为了方便调试,在编码风格上:</p><p>1 模块化<br>2 使用能够体现出具体意义的函数名和变量名</p><p>3 使用正确的缩进和代码块<br>4 良好的注释习惯</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充。。。</span><br></pre></td></tr></table></figure><h2 id="assert调试-（断言）"><a href="#assert调试-（断言）" class="headerlink" title="assert调试 （断言）"></a>assert调试 （断言）</h2><p>语法:<br>assert(bool表达式);<br>如果括号内的bool表达式为false<br>则会调用std:abort()函数<br>弹出对话框<br>assert宏需要头文件 cassert </p><p>可以通过 <code>#define NDEBUG</code> 关闭 要放在include前</p><p>static_assert用于编译时检查条件<br>static_assert(bool表达式,”错误信息”);<br>C++17新语法：<br>static_assert(bool表达式);<br>与assert不同,static_assert主要是用来在编译时检查重要的条件</p><p>因此检查的bool表达式中,只能用于常量</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164728551916780271586411%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164728551916780271586411&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81913729.142^v2^pc_search_insert_es_download,143^v4^control&amp;utm_term=stl&amp;spm=1018.2226.3001.4187">STL介绍</a></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>00P(Object Oriented Programming)即面向对象编程,本质上是一种编程思想,通过把我们编程中遇到的事物来抽象成对象来编程;与OOP相关的还有OOD(面向对象设计),00A(面向对分析)等;<br>OOP应当遵循OOD的原则,所有坏的OOP代码基本都是违反了OOD原则</p><p>SOLID原则 { 待百度 }</p><h3 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h3><p>封装：</p><p>继承：</p><p>多态：</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//影响后面出现的内容 只能类中使用</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hpRecover;-&gt;&gt;成员变量</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> -&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">hpRecover=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> hp;-&gt;&gt;成员变量</span><br><span class="line"><span class="keyword">int</span> damage; -&gt;&gt;成员变量</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span>-&gt;&gt;成员函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">role.hp-=damage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;<span class="comment">//外部定义后需要定义成这样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROLE::Act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>空class默认一个内存空间</p><p>inline成员函数： （推荐写在头文件里）</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数的指针 ， 代表定义的成员本身</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Role::GetHP</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const对象只能调用const成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const对象不能以任何方式改变,这是const的原则,在这个基本原则下,产生了一些列效应,比如const对象只能调用const成员函数; const对象无法调用别的成员<br>另外一个我们不注意的变化是,在const成员函数下,this指针也变成了const指针</p><p><strong>const类型转换</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_174156.jpg" alt=""></p><p><strong>mutable</strong></p><p>mutable声明的成员变量可以被const成员函数修改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> getHPCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> GetHP0 <span class="keyword">const</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Role:GetHP0 <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">getHPCont++;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在类的定义中有一种特殊的成员函数叫做构造函数.构造函数在类被创建时自动被调用,一般用来创建新的类实例时执行初始化操作构造函数与它所在的类同名,并且没有返回值,任何类都至少有一个构造函数;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hpRecover;</span><br><span class="line"><span class="keyword">void</span> lnit0</span><br><span class="line">&#123;</span><br><span class="line">hpRecover=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ROLE</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">int</span> damage;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>&#123;</span><br><span class="line">role.hp-=damage;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//跟java一样 ， 构造函数和类同名</span></span><br><span class="line">如果什么都不做 推荐<span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>被explicit关键字修饰的构造函数会禁用类型转换</p><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ROLE</span>(<span class="keyword">int</span> _lv,<span class="keyword">int</span> _damage):lv&#123;_lv&#125;, damage&#123;_damage&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>初始化时，初始化可以这样写快速初始化</p><p>效率更高，有时候只能这样去初始化</p><p><strong>使用成员初始化列表这样的方式构造类,要注意一个问题,即为成员赋值的顺序不是依据代码的顺序,而是成员变量在类的出现顺序;</strong></p><p><strong>委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</strong></p><p><code>ROLE(int _lv,int xx):ROLE(_lv)</code> 这种是委托构造，关于lv的都在ROLE这个构造函数里</p><p>副本构造函数</p><p>编译器为类指定了一个默认的副本构造函数,我们也可以手动指定副本构造函数</p><p><code>Role role1;   Role role2(role1);</code></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在类中还有一种特殊的成员函数,叫做析构函数,析构函数在类的生命周结束时,被自动调用,一般用来做 扫尾工作 比如释放内存,关闭句柄等等,如果一个类没有定义析构函数,那么编译器会自动添加一个空的析构函数,析构函数只能有一个;<br>析构函数没有参数,没有返回类型,一般不会手动调用,如果类的析构函数为空,最好使用关键字default来定义,例如:<br><code>~ROLE()=default;</code></p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>我们可以在类中通过static关键字声明一个类的静态成员变量,类的静态成员变量的特点:<br>1 所有类的实例中,共享类中的静态成员变量</p><p>2 类的静态成员变量在没有类的实例的情况下,依然可以访问</p><p>3 类的静态成员变量并不完全属于类 内存空间不属于类</p><p>实例类不管多少个，static都不变，被所有实例共享一个内存空间</p><p>c++17后 可以 <code>inline static int count&#123;20&#125;</code> 来定义</p><p><code>const static int count&#123;20&#125;</code></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>我们可以利用static关键字声明一个类的静态成员函数,类的静态成员函数有如下特点:</p><p>(1)不管有没有创建类的实例,都可以访问类的静态成员函数<br>(2类的静态成员函数不能访问非静态的成员变量<br>(3)类的静态成员函数不能是const<br>(4)类的静态成员函数不能使用this指针</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">可以通过<span class="keyword">friend</span>关键字声明一个函数为某个类的友元函数,友元函数可以访问该类中的所有成员</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetHP</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t.<span class="built_in">ResetHP</span>();</span><br><span class="line">t.hp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>俩个类交朋友的话 在另一个类上面声明 <code>class 类名</code> 即可</p><p>友元 不建议用</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>把一个类写在一个类里</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">int</span> mp;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line">我们可以在类的声明中再声明一个类,在类中声明的类称为嵌套类,而声明嵌套类的类称为外层类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>作用域</strong></p><p>嵌套类的声明在外层类中,因此嵌套类的作用域受外层类限定</p><p>假如要在类外声明女个Weapon对象<br><code>Role::Weapon mWpon;</code><br>嵌套类的作用域受封装属性管辖,即private封装的嵌套类是无法在类外使用的</p><p><strong>在类外定义嵌套类</strong></p><p><code>class ROLE::Weapen</code> 在外的类要这么写 。  函数、对象同理</p><p>函数指针情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span>;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>:</span>:Weapon&#123;</span><br><span class="line"><span class="function">Weapon*<span class="title">CreateWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">CreateWeapon</span>()&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嵌套类可以访问外层类的所有成员<br>外层类仅能访问嵌套类的公有成员</p><p><strong>局部类</strong></p><p>定义在函数内的类称为局部类</p><p>局部类的定义必须写在类内</p><p>局部类中不允许使用静态成员变量</p><p>局部类可以访问全局变量</p><p><strong>嵌套类模块化问题</strong></p><p>多文件时。嵌套头文件，类出错  注意头文件</p><h2 id="类的成员函数的函数指针"><a href="#类的成员函数的函数指针" class="headerlink" title="类的成员函数的函数指针"></a>类的成员函数的函数指针</h2><h2 id="从底层理解类（逆向）"><a href="#从底层理解类（逆向）" class="headerlink" title="从底层理解类（逆向）"></a>从底层理解类（逆向）</h2><p>{待补充}</p><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>在OOP编程中,万物皆对象,我们如何让这些对象也能够像普通类型一样实现加减乘除呢?比如我们学习过的std:string对象<br><code>std:string str=&quot;大家好!&quot;;</code><br><code>str=str+”才是真的好!&quot;;</code><br>要实现这个功能我们就要对运算符+重新进行设计,当我们的对象进行+运算时不再是编译器默认的+预算,而是进入我们指定的函数,这种重新设计运算符规则的技术就称为运算符重载!<br>语法:<code>返回类型operator运算符0</code><br>//例如 <code>bool operator&lt;(const Role&amp; role);</code></p><p>非类成员函数实现需要使用友元定义</p><p>即： <code>man&lt;woman == man.operator&lt;(woman) == man&lt;woman</code></p><h3 id="原则和时机"><a href="#原则和时机" class="headerlink" title="原则和时机"></a>原则和时机</h3><p><strong>意义</strong></p><p>(1）让类也支持原生的运算比如＋-*/<br>(2）提升对程序的控制权比如重载new delete newdelete[<br>备注:<br>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率</p><p><strong>限制</strong></p><p>(1)不能自创运算符比如=== ,=&lt;&gt;=只能重载现有运算符</p><p>(2)以下运算符不能重载<br>(a)对象访问运算符．例如 user.hp</p><p>(b)作用域解析运算符::例如std::cout</p><p>(c)求大小的运算符sizeof 例如sizeof(int)</p><p>(d)条件运算符?:例如b=a&gt;c?100:200<br>(3)不能修改运算符本身的优先级,相关性<br>(4)在C++17后，也不能修改运算符的操作数的计算顺序，在C++17前，编译器可以自由选择如何计算（未定义行为)</p><p>(5)除了delete/delete和new/new外,不能对原生数据类型的其他运算符进行重载，比如把char类型的+定义为-</p><p>(6)除了new和delete以为，其他运算符的arity(运算符关联的操作数的个数或者是关联的参数）一律不能修改</p><p><strong>原则</strong></p><p>(1)不要改变运算符本身的意义,比如把加法重载为减法<br>(2)不建议重载逻辑运算符&amp;&amp; ||,取址运算符&amp; 逗号运算符，<br>备注:重载后的逻辑运算符将不会进行短路测试，在C++17标准前，编译器可以自由决定先计算左操作数还是右操作数,在C++17后计算的顺序规定为先计算左再计算右</p><p><strong>语法</strong><br>二元运算符的重载<br>利用全局函数<br><code>返回类型 operator 运算符(类型 左操作数,类型 右操作数）</code><br>利用类的成员函数<br><code>返回类型 operator 运算符(类型 右操作数)</code><br>一元运算符的重载<br>利用全局函数返回<br><code>返回类型 operator 运算符(类型 操作数)</code><br>利用类的成员函数<br><code>返回类型 operator 运算符()</code></p><p>有的运算符只能重载为类的成员函数,有些运算符只能重载为全局函数,有些运算符既可以重载为类的成员函数又可以重载为全局函数,如果一个运算符既可以重载为成员函数又可以重载为全局函数,我们一般推荐重载为类的成员函数,因为类的成员函数可以是虚函数,单全局函数不能是虚函数,如果这个运算符不修改对象,应该将这个成员函数限定为const<br>运算符重载的参数一般可以传递值或者引用,大部分情况下,能够传递引用就不要传递值,对于不会修改的值最好是限定为const,某些时候要擅用使用右值引用&amp;&amp;作为参数<br>运算符重载的返回值一般来说可以是任何类型,但是尽量要符合运算符的原意,比如把&gt;运算符返回指针类型,把+返回bool类型,都不是很好的选择</p><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>{待补充}</p><p>很多符号</p><h2 id="重载类型转换"><a href="#重载类型转换" class="headerlink" title="重载类型转换"></a>重载类型转换</h2><p>1 类型转换运算符只能重载为类的成员函数</p><p>2 类型转换运算符没有返回值。它的返回值由类型转换的类型来决定</p><p>3 语法 ``</p><p>4 <code>operator 类型() const</code></p><p>{待补充}</p><p><code>什么是隐试类型转换： float x=2  此时2是int型 这是就是隐式类型转换转成float型</code></p><h2 id="重载内存分配"><a href="#重载内存分配" class="headerlink" title="重载内存分配"></a>重载内存分配</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>假设有一个类animal现在我们基于animal类创造一个新类monkey,那么我们说类animal</p><p>monkey类的基类(父类),moneky类是anima类的派生类(子类),子类自动继承包含了父类的成员变量以及成员函数!</p><p>子类不能继承父类的构造函数,析构函数,重载赋值运算符,虽然不能继承,但是这些内容依然是存在于父类中的。</p><p>如果我们继续基于monkey创造一个新类bigMonkey,那么monkey是bigMonkey的直接基类,animal是bigMonkey的间接基类</p><p><code>class 类名:访问属性[public|private|protected] 父类名称</code></p><p>protected: 只有子类和友元可以访问</p><p>不想被别人继承的话 后面加 <code>final</code></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220316202707.png" alt=""></p><p><strong>修改继承成员的访问属性</strong></p><p>可以用<code>using 基类名::成员名</code> 来修改继承来的成员的访问属性</p><p><strong>使用proteted和private访问属性有几个好处</strong></p><p>可以更好的封装父类成员</p><p>可以在子类作为基础进行派生类的时候提供继承控制</p><p>将保护属性为private的父类产生的子类作为基类的时候,派生类继承但不能访问构建其父类的基类成员</p><p>将保护属性为protected的父类产生的子类作为基类的时候,派生类继承且可以访问其非私有成员</p><p><strong>继承访问属性的选择</strong></p><p>一般来说,尽量射击类的成员变量为private,如果需要访问这些成员变量,应该提供setter以及getter函数</p><h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p><strong>派生类</strong></p><p>构造顺序:先构造基类再构造派生类 (父亲-&gt;儿子)</p><p><strong>父本构造函数</strong></p><p>一个由另一个来复制.  执行时就不会调用原本的构造函数了</p><p>exp: <code>actObject(const actObject&amp; obj)</code></p><p><strong>继承构造函数</strong></p><p>通过 <code>using 基类::基类构造函数</code> 可以继承基类构造函数,但是默认构造函数与副本构造函数不会被继承</p><h2 id="继承析构函数"><a href="#继承析构函数" class="headerlink" title="继承析构函数"></a>继承析构函数</h2><p>先释放派生类,再释放基类  , 与构造顺序相反</p><p>当基类和派生类的成员函数同名时,要分俩种情况:</p><p>1 函数名相同,参数不同  <code>using 基类::函数名</code></p><p>2 函数名相同,参数相同 <code>基类::函数名</code></p><p>exp: <code>obj.lastObject::lastlastObject::show();</code></p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>一个类可以拥有多个父类,并且可以继承各个父类的成员 (不推荐用)</p><p><code>class xx: public x1 , public x2 &#123;&#125;;</code></p><p><strong>多重继承带来的重复继承问题</strong></p><p>问题时继承来的东西重复继承</p><p>首先可以强制指定解决√</p><p>另一方法: <strong>虚基类</strong>  <code>class xx:public virtual x&#123;&#125;;</code></p><p>意思时只引入一次,第二次不引入</p><h2 id="内存角度理解"><a href="#内存角度理解" class="headerlink" title="内存角度理解"></a>内存角度理解</h2><p>{深入理解 待补充}</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="对象多态"><a href="#对象多态" class="headerlink" title="对象多态"></a>对象多态</h2><p>exp: 人是动物√  动物是人×  </p><p>即第一个第向上转型(父类=&gt;子类 父类表达子类), 第二个是向下转型(子类=&gt;父类 子类表达父类)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    peole  lz;</span><br><span class="line">    lz.age = <span class="number">22</span>;</span><br><span class="line">    lz.monry=<span class="number">1</span>;</span><br><span class="line">    animal* anm1=&amp;lz;</span><br><span class="line">    people* humn=(people*)anm1;</span><br><span class="line">    <span class="comment">//不推荐这样用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存切片</strong></p><p>exp: 人类转成动物类的时候, 有些东西会丢掉(比如钱), 这就是内存切片</p><h3 id="对象多态详解"><a href="#对象多态详解" class="headerlink" title="对象多态详解"></a>对象多态详解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moveobj</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monstermove</span>:</span><span class="keyword">public</span> moveobj</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">monstermove monster;</span><br><span class="line">moveobj* _move=&amp;monster;<span class="comment">//隐式类型转换 向上转型</span></span><br><span class="line"></span><br><span class="line">monstermove* _pmove=&amp;_move; <span class="comment">//隐式 向下转型 不允许!  可以强制</span></span><br><span class="line">monstermove* _pmove=(monstermove*)_move;</span><br><span class="line">monstermove* _pmove=<span class="keyword">static_cast</span>&lt;monstermove*&gt;_move; <span class="comment">//会检测</span></span><br><span class="line">待补充...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="动态强制转换"><a href="#动态强制转换" class="headerlink" title="动态强制转换"></a>动态强制转换</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220317_022820.jpg" alt=""></p><p>只能用于多态类</p><h2 id="方法多态-多态类"><a href="#方法多态-多态类" class="headerlink" title="方法多态(多态类)"></a>方法多态(多态类)</h2><p><strong>静态多态</strong> </p><p>①函数重载  <code>函数(&amp;类实例化的对象)</code> 从而判断执行哪一个函数</p><p>②函数模板</p><p><strong>动态多态</strong></p><h3 id="virtual虚函数"><a href="#virtual虚函数" class="headerlink" title="virtual虚函数"></a>virtual虚函数</h3><p>告诉派生类 我这个函数是虚的 你需要重写</p><p>virtual 放在定义函数的前面</p><p><strong>使用条件</strong></p><p>virtual只能写在类的内部声明或者定义,不能把virtual写在类的外部定义中</p><p>调用类的对象是无法使用虚函数的,必须使用基类指针来实现虚函数的调用</p><p>虚函数在派生类和基类中必须具有相同的及参数列表</p><p>虚函数在派生类和基类中返回值要求基本一致,但是当返回类型为类类型的指针和引用时除外</p><p>虚函数不能是函数模板</p><p><code>类名* 函数名() override</code> 代表我这个函数是继承来的</p><p>final 代表不再被继承.</p><ul><li><p>虚函数的执行也是遵循类的生成和销毁的(自我理解)</p></li><li><p>可以使用 <code>基类::基类函数()</code> 强行调用基类函数</p></li><li><p>默认实参在基类已经定义了那么派生类的修改是无效的,即使执行派生类的函数</p></li><li>当你通过基类声明派生类对象 <code>基类* p=new 派生类();</code> 然后释放内存调用析构函数的时候,调用的是基类的析构函数(因为派生函数不是虚函数,你是通过基类声明的对象)  容易造成内存泄漏,所以需要 进行 虚析构函数 , 即可正常.</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>在实际的项目设计中,可能出现一种情况,父类有N个派生类<br>比如Animal类派生出Dog和Cat<br>此时我们在Animal类中是无法确定Move函数的内容的,这个时候为Animal类设计Move函数的内容是无意义的,这种情况下我们可以将Move函数设计为纯虚函数<br><code>void virtual Move(=0;</code><br>=0可以将指定的函数设置为纯虚函数</p><p><strong>为什么要定义成纯虚函数</strong>  为了利用它的多态性,实现多态</p><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>有纯虚函数的类  不能用于实体</p><p>拥有纯虚函数的类称为抽象类,因为该类的函数没有实现,因此不能创建抽象类的实例,但是却可以使用抽象类的指针和引用作为返回或者参数!<br>抽象类的构造函数因为不能实际使用,所以一般推荐把抽象类的构造函数定义为protected<br>抽象类的派生类如果没有定义纯虚函数,则该派生类依然是抽象类</p><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p>类中所有(极大部分)函数定义为纯虚函数的类成为接口类</p><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p><code>typeid(类型).name</code></p><p>输出类型名字 但是必须要有多态</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>c++ 的基础还是有些没有总结好,后面补充</p>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 菜鸡学习❀ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04美化</title>
      <link href="/2022/02/13/Ubuntu%E7%BE%8E%E5%8C%96/"/>
      <url>/2022/02/13/Ubuntu%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>主题<a href="https://www.pling.com/s/Gnome">https://www.pling.com/s/Gnome</a><br>扩展<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="登陆-Ubuntu-账号，开启-Livepatch-功能"><a href="#登陆-Ubuntu-账号，开启-Livepatch-功能" class="headerlink" title="登陆 Ubuntu 账号，开启 Livepatch 功能"></a>登陆 Ubuntu 账号，开启 Livepatch 功能</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/ab4a30e9e73b39cb5b8750f8f869d677bcda32a7.png" alt=""></p><p>点击 Ubuntu Single-On 就会弹出登陆页面了，这里也可以先不登陆，直接点击跳过，后面再登陆。</p><p>也可以通过在已安装软件列表里面搜索 Software &amp; Updates 软件，如下图，打开后登陆 Ubuntu 账号。</p><p>这里有问题,先不看</p><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h3 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions</span><br><span class="line"></span><br><span class="line">删掉原来的ubuntu-dock (emmmm)</span><br><span class="line">sudo apt-get autoremove --purge gnome-shell-extension-ubuntu-dock -y</span><br></pre></td></tr></table></figure><p>用浏览器打开扩展插件商店，地址：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/b1a2f8621f7162ac6e8005dd6b0cbfeb47f354ba.png" alt=""></p><p>下载主题McMojave <a href="https://www.gnome-look.org/p/1275087/">https://www.gnome-look.org/p/1275087/</a></p><p>icon theme <a href="https://www.gnome-look.org/s/Gnome/p/1348081">https://www.gnome-look.org/s/Gnome/p/1348081</a></p><p>自己找 然后解压放在/usr/share/themes和icons下面</p><p>然后在gnome里面使用就可以</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS1 Noetic</title>
      <link href="/2022/02/05/ros%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/05/ros%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">如何移植别人的工程:</span><br><span class="line">在根目录 catkin_make 后 ,会报错,然后修改的地方在build里,需要更改Cmake.txt以及 Makefile ,再补上所需要的依赖,就可以了</span><br><span class="line">安装依赖:</span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #自己修改</span><br><span class="line">rosdep install --from-paths ~/catkin_ws/src --ignore-src -r</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h1 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="常见操作指令"><a href="#常见操作指令" class="headerlink" title="常见操作指令"></a>常见操作指令</h1><p><strong>查找：</strong><br>rosc/roscd：切换当前工作目录到ros的某个程序包<br>rosls：按程序包的名称执行ls命令<br>catkin_ctreate_pkg：创建功能包<br>catkin_make：编译ROS工作空间，该src空间下所有程序包以及其子包都会被编译</p><p>-</p><p>roscore：启动管理器<br>rosrun：运行ROS程序包中的可执行文件<br>roslaunch：启动roscore，本地结点和远程结点，设置服务器参数（ssh）<br>roslaunch package_name filename.launch：启动包中的一个文件<br>rospack：获取程序包有关信息<br>rospack find：返回程序包的路径<br>rospack list：获取所有的程序包<br>rosdep：rosdep install package_name 可以下载安装ROS 程序包所需要的系统依赖项<br>roswtf：可以检查ROS系统并尝试发现问题<br>rostopic -h：查看所有Topic操作<br>rostopic list：获取所有的Topic列表<br>rosrun rqt_plot rqt_plot：图形化显示Topic<br>rostopic echo ‘topic namae’：查看某个Topic的信息</p><h1 id="video"><a href="#video" class="headerlink" title="video"></a>video</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg usb_cam std_msgs roscpp cv_bridge sensor_msgs image_transport</span><br><span class="line">    </span><br><span class="line">img_publisher.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_publisher&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Publisher pub = it.<span class="built_in">advertise</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  cv::VideoCapture cap;</span><br><span class="line">  cv::Mat frame;</span><br><span class="line">  <span class="keyword">int</span> deviceID=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">deviceID=argv[<span class="number">1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> apiID=cv::CAP_ANY;</span><br><span class="line">  cap.<span class="built_in">open</span>(deviceID+apiID);</span><br><span class="line">  <span class="keyword">if</span>(!cap.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">std::cerr&lt;&lt;<span class="string">&quot;ERROR! Unable to open camera&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">cap.<span class="built_in">read</span>(frame);</span><br><span class="line"><span class="keyword">if</span>(!frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, frame).<span class="built_in">toImageMsg</span>();</span><br><span class="line">pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_viewer.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">imageCallback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;view&quot;</span>, cv_bridge::<span class="built_in">toCvShare</span>(msg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (cv_bridge::Exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;</span>, msg-&gt;encoding.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_viewer&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  cv::<span class="built_in">startWindowThread</span>();</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Subscriber sub = it.<span class="built_in">subscribe</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">  $&#123;OpenCV_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">add_executable</span>(img_publisher src/img_publisher.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(img_viewer src/img_viewer.cpp)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_publisher $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_viewer $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;build_depend&gt;opencv2&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;opencv2&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;opencv2&lt;/exec_depend&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic">https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸡学习❀ </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础再学习</title>
      <link href="/2022/02/01/Cplus%E8%A1%A5%E5%85%85/"/>
      <url>/2022/02/01/Cplus%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<p>C++基础再学习<br>PS:之前学了一点,不过只在opencv简单使用,算法题和面试题,包括ROS等,随着python的不断壮大,python似乎是更好用的工具.不过C++还是挺重要的,对于嵌入式领域还是需要的.</p><p>[TOC]</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><p>创建枚举，需要使用关键字 enum。枚举类型的一般形式为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span> </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><br>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p><p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure><br>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br><code>enum color &#123; red, green=5, blue &#125;;</code><br>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container"><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>const</td><td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr><tr><td>volatile</td><td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td></tr><tr><td>restrict</td><td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr></tbody></table></div><h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h1><h2 id="auto-c-17开始弃用"><a href="#auto-c-17开始弃用" class="headerlink" title="auto(c++17开始弃用)"></a>auto(c++17开始弃用)</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h2 id="register-c-17开始弃用"><a href="#register-c-17开始弃用" class="headerlink" title="register(c++17开始弃用)"></a>register(c++17开始弃用)</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><p><code>&#123;   register int  miles; &#125;</code></p><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h2 id="static存储类"><a href="#static存储类" class="headerlink" title="static存储类"></a>static存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/1219357fb4b425f30463c902c44f32c55a51b8e6.png" alt=""></p><h2 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p>第一个文件：main.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件：support.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure><p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./write</span><br><span class="line">Count is 5</span><br></pre></td></tr></table></figure><h2 id="mutable存储类"><a href="#mutable存储类" class="headerlink" title="mutable存储类"></a>mutable存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象.它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h2 id="thread-local-C-11-存储类"><a href="#thread-local-C-11-存储类" class="headerlink" title="thread_local (C++11)存储类"></a>thread_local (C++11)存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值可以表示为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure><p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p><p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>其实，不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table></div><p><code>#include  &lt;cstring&gt;</code></p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>关于面向对象:</p><p>exampl:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">   string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">   string str3;</span><br><span class="line">   <span class="keyword">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str3 : runoob</span><br><span class="line">str1 + str2 : runoobgoogle</span><br><span class="line">str3.size() :  12</span><br></pre></td></tr></table></figure><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p><strong>和指针的区别:</strong></p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="keyword">int</span>    i;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="keyword">int</span>&amp;    r = i;</span><br><span class="line">   <span class="keyword">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p><div class="table-container"><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">把引用作为参数</a></td><td style="text-align:left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">把引用作为返回值</a></td><td style="text-align:left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td></tr></tbody></table></div><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><div class="table-container"><table><thead><tr><th style="text-align:left">头文件</th><th style="text-align:left">函数和描述</th></tr></thead><tbody><tr><td style="text-align:left"><iostream></td><td style="text-align:left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td style="text-align:left"><iomanip></td><td style="text-align:left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td style="text-align:left"><fstream></td><td style="text-align:left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table></div><p><strong>延申待补充……</strong></p><h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><h1 id="C-高级"><a href="#C-高级" class="headerlink" title="C++高级"></a>C++高级</h1>]]></content>
      
      
      <categories>
          
          <category> 技术帖 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 菜鸡学习❀ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习途中小Tips</title>
      <link href="/2022/01/10/Normal%20Tips/"/>
      <url>/2022/01/10/Normal%20Tips/</url>
      
        <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><strong>替换github.com 为 hub.fastgit.org</strong></p><hr><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><hr><p>批量替换:<br>:%s/abc/123/g c (用c可以确认是否替换)</p><p>编辑文件:(默认模式下)</p><div class="table-container"><table><thead><tr><th>指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>i</td><td style="text-align:center">在当前光标所在字符的前面，转为编辑模式。</td></tr><tr><td>I</td><td style="text-align:center">在当前光标所在行的行首转换为编辑模式。</td></tr><tr><td>a</td><td style="text-align:center">在当前光标所在字符的后面，转为编辑模式。</td></tr><tr><td>A</td><td style="text-align:center">在光标所在行的行尾，转换为编辑模式。</td></tr><tr><td>o</td><td style="text-align:center">在当前光标所在行的下方，新建一行，并转为编辑模式。</td></tr><tr><td>O</td><td style="text-align:center">在当前光标所在行的上方，新建一行，并转为编辑模式。</td></tr></tbody></table></div><p>查找: /xxx       <code>n  在同一个方向重复上一次搜索命令   N 在反方向重复上一次搜索命令</code></p><hr><p>选中 单词开头或者结尾 (在v模式下) 按e进行选择</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><strong>配置ssh</strong></p><p><code>sudo apt install openssh-server</code></p><p><code>service ssh start</code></p><p><strong>重新连接Ubuntu联网指令：</strong></p><p><code>sudo /etc/init.d/network-manager restart</code></p><p><strong>重新挂载共享文件夹</strong></p><p><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code></p><p><strong>搜wifi:</strong></p><p><code>sudo iw dev wlan0 scan | grep SSID</code> </p><p><strong>交叉编译树莓派gcc：</strong></p><p><code>arm-linux-gnueabihf-gcc</code></p><p><strong>树莓派安全关机：</strong></p><p><code>sudo shutdown -h now</code></p><p><strong>树莓派重启：</strong></p><p><code>sudo reboot</code><br><strong>树莓派传输文件使用fillzeila：前面加上</strong> <code>sftp://</code></p><p><strong>树莓派拍照：</strong> <code>raspistill -o image.jpg</code><br>监控   :8080</p><p><strong>安装软件</strong>: <code>`sudo  dpkg  -itar xvf xxx</code><br><strong>Linux查看pdf：</strong><code>zathura</code><br><strong>LINUX解压文件：</strong><code>tar xvf xxx</code></p><p><strong>摄像头推流：</strong></p><p><code>/usr/local/bin/mjpg_streamer -i &quot;/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720&quot; -o &quot;/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot;</code></p><p><strong>临时路径：</strong></p><p><code>export LD_LIBRARY_PATH=/home/lz/face/samplecode/ASFTestDemo/linux_so/:$LD_LIBRARY_PATH</code> </p><p><strong>opencv:</strong><br>    编译时 加 <code>pkg-config --cflags --libs opencv</code></p><h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p><strong>防火墙操作</strong></p><p>firewall-cmd —list-all                                              列出所有端口号白名单<br>firewall-cmd —add-port=8888/tcp —permanent              添加一个8888端口为白名单<br>firewall-cmd —reload                                             更新防火墙操作</p><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p><strong>百度文库下载:</strong></p><p>网址baidu后面加三个v </p><hr><p><strong>Typora+七牛云配置:</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 存储空间名</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义域名</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span>:  <span class="string">&quot;&quot;</span>, <span class="comment">// 存储区域编号</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 网址后缀，比如？imgslim</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;img/&quot;</span> <span class="comment">// 自定义存储路径，比如 img/</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pyhton"><a href="#pyhton" class="headerlink" title="pyhton"></a>pyhton</h1><p><strong>conda install 问题</strong></p><p>终端中输入代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels conda-forge</span><br></pre></td></tr></table></figure><p>再通过conda或者pip安装自己需要的包就不会再出问题了。</p><p>注意channel不一定是conda-forge，根据你需要安装包的类型，具体包属于那个类型可以通过代码来查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anaconda search -t conda 要安装的包</span><br></pre></td></tr></table></figure><p>当然啦如果你需要安装的包比较少也可以直接按照上面给出链接的博客方法进行操作</p><p><code>conda activate tensorflow</code></p><p><code>conda create -n tensorflow python=3.8.5</code></p><p><strong>Windows pip install</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install 包名 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 小提示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客常用配置</title>
      <link href="/2022/01/01/%E6%96%87%E7%AB%A0Tips/"/>
      <url>/2022/01/01/%E6%96%87%E7%AB%A0Tips/</url>
      
        <content type="html"><![CDATA[<p>Front-matter 是markdown 文件最上方以 —- 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于頁面配置<br>Post Front-matter 用于文章頁配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220120000604.png" alt=""></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:缩略图</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br><span class="line">another:::::::::::::::::::</span><br><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">author: </span><br><span class="line">img: /medias/banner/7.jpg</span><br><span class="line">coverImg: /medias/banner/7.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">toc: true</span><br><span class="line">password: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110</span><br><span class="line">mathjax: true</span><br><span class="line">summary: 自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- </span><br><span class="line">categories:</span><br><span class="line">- </span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://fastly.jsdelivr.net/gh/zhezheup/picture-house/20220120000809.png" alt=""></p><h3 id="新-md"><a href="#新-md" class="headerlink" title="新.md"></a>新.md</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Copyright-beautify # 文章名称</span><br><span class="line">date: 2021-03-02 13:52:46 # 文章发布日期</span><br><span class="line">updated: 2021-03-02 13:52:46 # 文章更新日期</span><br><span class="line">copyright_author: Nesxc # 作者覆写</span><br><span class="line">copyright_url: #https://www.nesxc.com/post/hexocc.html # 原文链接覆写</span><br><span class="line">license: # 许可协议名称覆写</span><br><span class="line">license_url: # 许可协议链接覆写</span><br><span class="line">author: </span><br><span class="line">img: </span><br><span class="line">coverImg: </span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">toc: true</span><br><span class="line">mathjax: false</span><br><span class="line">password:</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">sticky: 1 #置顶用 越大置顶优先级越大</span><br><span class="line">aside: false&lt;-- 关闭侧边栏</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建日期</span><br><span class="line">updated: 更新日期</span><br><span class="line">cover: 文章封面</span><br><span class="line">description: 文章描述</span><br><span class="line">swiper_index: 1 #置顶轮播图顺序，需填非负整数，数字越大越靠前</span><br><span class="line">comments: false #关闭评论</span><br><span class="line">subtitle: 左上角显示</span><br><span class="line">description: 提示-&gt;左上角</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>给 js 脚本加上 <code>defer</code> 和 <code>ansyc</code> 属性来实现异步加载，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">https://unpkg.zhimg.com/vue@2.6.11&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;https://fastly.jsdelivr.net/gh/zjwo/CDN/js/pyq/pyq.min.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Boke相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
