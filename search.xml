<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++基础</title>
      <link href="/2022/03/16/Cplus2/"/>
      <url>/2022/03/16/Cplus2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础More"><a href="#基础More" class="headerlink" title="基础More"></a>基础More</h1><p><code>size_t : typedef unsigned int</code></p><p>C++的静态转换: b为要转换的内容</p><p><code>int a=static_cast&lt;int 目标类型&gt;(b);</code></p><p>查看变量类型: <code>typeid(变量).name();</code></p><p>格式化输出流:</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/IMG_20220224_020107.jpg" alt="IMG_20220224_020107"></p><p>运算优先级:(优先级从上到下)</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/IMG_20220224_020948.jpg" alt="IMG_20220224_020948"></p><h3 id="枚举变量"><a href="#枚举变量" class="headerlink" title="枚举变量"></a>枚举变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">xx</span>:</span><span class="keyword">int</span> <span class="comment">//自动递增1,从上往下</span></span><br><span class="line">&#123;</span><br><span class="line">normal,</span><br><span class="line">    high,</span><br><span class="line">    low=xx,</span><br><span class="line">    other, other1=other<span class="comment">//多个情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">xx use_xxn&#123;xx::normal&#125;;</span><br><span class="line">xx use_xxh&#123;xx::high&#125;;</span><br></pre></td></tr></table></figure><p>1.提高代码的可读性和安全性</p><p>2.枚举类型默认int型</p><p>3.枚举类型成员只能是整数类型</p><p>4.枚举类型和其他类型转换需要强制转换</p><h3 id="自定义变量名称"><a href="#自定义变量名称" class="headerlink" title="自定义变量名称"></a>自定义变量名称</h3><p>三种方式:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A Typename <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">typedef</span> Typename A; <span class="comment">//Typename被A替换</span></span><br><span class="line"><span class="keyword">using</span> A=Typename; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p><strong>自定义命名空间:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> yournamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ...</span><br><span class="line">    <span class="function">string</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>变量的声明周期:</strong></p><p>变量生命在代码块结束后死亡.</p><p>全局变量的生命程序运行一直存在</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::xx <span class="comment">//定义后使用双冒号使用</span></span><br></pre></td></tr></table></figure><p><strong>位运算:</strong></p><p>输出二进制文件.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">引用 bitset头文件</span><br><span class="line">std::bitset&lt;要显示的二进制位数&gt;(要显示的变量);</span><br></pre></td></tr></table></figure><p><code>std::boolalpha 可以将流的输出控制为bool类型</code></p><p><strong>字符处理</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_111853.jpg" alt=""></p><p><strong>判断</strong></p><p>C++17语法</p><p>if(int a; check() ) {}</p><p>switch(变量声明 ；条件（）) {}</p><p><code>goto的使用 ： input&#123;代码段&#125;  ... goto input；</code></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的地址连续</p><p>求大小</p><p><code>sizeof(a[])/sizeof(a[0])</code>  or <code>sizeof(数组名/sizeof(类型名))</code></p><p><strong>基于数组的循环</strong></p><p><code>for(变量类型 变量名称 : 数组) &#123;&#125;</code></p><p><code>for(auto 变量名称 : 数组) &#123;&#125;</code></p><h2 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <array></h1><p><code>std::array&lt; 变量类型 , 元素数量&gt; 变量名;</code></p><p><code>exp: std::array&lt;int ,5&gt;stuID; //五个学生的学号</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stuID.size();</span><br><span class="line">stuID.fill(x); //将所有元素都设置为x</span><br><span class="line">stuID.at(1); //返回stu[1]里的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p>array的优点基本都具备 size fill at</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <vector></h1><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_155716.jpg" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_160124.jpg" alt=""></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>c++声明指针需要初始化</p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p><code>int* array[10] 数组里面存了10个指针</code></p><p> <strong>指针详细 {待补充}</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="c内存分配"><a href="#c内存分配" class="headerlink" title="c内存分配"></a>c内存分配</h3><p><code>void*  malloc</code> ： 用法{ }</p><p><code>nullptr 相当于0 （c++17新）</code></p><p><code>void* calloc(size_t count , size_t size);</code> : 为用户分配count*size字节个内存</p><p><code>void* realloc(void* _Block,size_t_size)</code> : 为用户重新分配内存，_Block是用户已经分配好的内存，Size是要求重新分配的大小</p><p><code>void* free(void* _Block)</code> : 释放内存</p><h3 id="c-内存分配"><a href="#c-内存分配" class="headerlink" title="c++内存分配"></a>c++内存分配</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_002002.jpg" alt=""></p><p><strong>释放内存：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>  )  <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[x]) <span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><p><strong>风险</strong></p><ul><li><p>悬挂指针：释放了还在继续使用释放掉的地址</p></li><li><p>内存碎片：频繁申请和释放小块内存会造成内存碎片，原则上可以使用，实际上使得我们无法分配新的内存.但是new和delete的算法会帮助我们尽量规避</p></li></ul><p><strong>复制内存</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220310012821.png" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_013233.jpg" alt=""></p><h3 id="malloc和new本质区别"><a href="#malloc和new本质区别" class="headerlink" title="malloc和new本质区别"></a>malloc和new本质区别</h3><p>对于普通的数据类型来说malloc和new没什么区别,但是对于类来说,malloc仅仅是分配内存而new除了分配内存以外还会调用构造函数!</p><h3 id="free和delete本质区别"><a href="#free和delete本质区别" class="headerlink" title="free和delete本质区别"></a>free和delete本质区别</h3><p>对于普通的数据类型来说free和delete没有什么区别,但是对于类来说,free仅仅是释放内存空间,而delete不仅释放内存空间,还会调用类的析构函数</p><h3 id="delete和delete-本质区别"><a href="#delete和delete-本质区别" class="headerlink" title="delete和delete[]本质区别"></a>delete和delete[]本质区别</h3><p>对于普通的数据类型来说deletc和delete[]没有什么区别,但是对于类来说,delete仅仅是释放内存空间,且调用第一个元素的析构函数,而delete[]不仅释放内存空间,还会调用每一个元素的析构函数</p><p>对普通数据类型无所谓</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>引用的本质其实就是一种被阉割了的指针，虽然我们取址引用变量得到的是原地址的内存地址，但是引用变量也是占用内存的</code></p><p>引用需要初始化</p><p>提高代码效率，{个人觉得类似于软连接}</p><p>语法： <code>数据类型&amp;变量名称&#123;引用对象的名称&#125;；</code></p><p><code>exp： int a&#123;500&#125;;  int&amp; la&#123;a&#125;;</code> la=500即a=5200.</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_015706.jpg" alt=""></p><p>第一种声明不允许用数组方式访问，第二种可以。</p><p>智能指针不允许指向别的智能指针。具有唯一性。</p><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset();</span><br><span class="line">//reset将会释放std::unique_ptr的内存空间，并且设置为nullptr</span><br><span class="line">get();</span><br><span class="line">//get返回std::unique_ptr的指针</span><br><span class="line">release();</span><br><span class="line">//release返回std::unique_ptr的指针,并且设置为nullptr，但是不会释放占用的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021212.jpg" alt=""></p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021553_edit_658178805450610.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr的复制</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrA&#123;&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrB&#123;std::make_shared&lt;int&gt;(5)&#125;;</span><br><span class="line">ptrA=ptrB;</span><br><span class="line">··························································</span><br><span class="line">//获得计数</span><br><span class="line">long std::shared_ptr.use_count();</span><br><span class="line">.use_count();会返回当前指针共有多少个对象调用</span><br><span class="line"></span><br><span class="line">bool std::shared_ptr.unique();</span><br><span class="line">//unique()会返回以一个bool值，if当前智能指针是唯一拥有该指针的人，返回true</span><br><span class="line"></span><br><span class="line">std::shared_ptr.reset();</span><br><span class="line">//将当前共享指针设置为nullptr，如果是最后一个拥有该指针的对象，释放内存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性</strong></p><p>可以有多个std::shared_ptr指向同一地址，同一地址下只有最后一个std::shared_ptr释放的时候，才会释放其所占用的空间，std::shared_ptr会记录当前有多少个智能指针调用</p><h2 id="C原生字符串"><a href="#C原生字符串" class="headerlink" title="C原生字符串"></a>C原生字符串</h2><p>字符串就是指针，数组</p><p>&lt;! 待补充 —&gt;</p><p><code>wchar_t str[0xff]&#123;L&quot;HEllo&quot;&#125;;</code> 宽字节常量</p><p>（使用utf-16实现UNICODE）</p><p><code>使用UNICODE标准 ： setlocale(LC_ALL,&quot;chs&quot;)</code>  <code>使用wcout输出</code></p><p>std::cout 默认输出char类型的值时会当作字符串进行处理。</p><h2 id="联合体-union"><a href="#联合体-union" class="headerlink" title="联合体 union"></a>联合体 union</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">&#125;</span><br><span class="line">exp:</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> shp;</span><br><span class="line">    <span class="keyword">int</span>   xhp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过union可以创建一个联合体，union中的成员变量共享内存，因此 <strong>union的数据类型大小由其最大的成员变量决定</strong></p><p>union中任意一成员变量发生改变都可能影响别的变量</p><p><strong>匿名联合体、结构体</strong></p><p>顾名思义，没有名字的联合体和结构体</p><p>一般只用一次</p><h2 id="C-字符串string"><a href="#C-字符串string" class="headerlink" title="C++字符串string"></a>C++字符串string</h2><p><code>#include &lt;string&gt;</code></p><p>定义： <code>std::string str&#123;&quot;wow!&quot;&#125;;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; , 要截取的长度&#125;</code> </p><p>exp：<code>string str&#123;&quot;1234&quot;,2&#125;; str=&quot;12&quot;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; ，起始位置 ， 要截取的长度&#125;</code></p><p><code>std::string 变量名称(要复制的个数，&#39;字符&#39;)</code></p><p><strong>连接字符串</strong> <code>std::string str(6,&#39;a&#39;);   str=str+&quot;123;  str=&quot;aaa123&quot;</code></p><p><strong>连接字符串和数字</strong> <code>std::string str = std::to_string(数字)；</code></p><p><strong>字符串连接字符串</strong></p><p>字符串不能直接和别的字符串连接，可以使用临时变量解决(std::string(xx));</p><p>可以 <code>&quot;变量&quot;&quot;变量&quot;  变成&quot;变量变量&quot;</code></p><p>也可以<code>str.append(&quot;你要拼接的内容&quot;)</code> 可以无限加</p><p><strong>字符串连接字符</strong>  直接+’字符’  即可</p><p><strong>截取字符串</strong> <code>.substr(起始位置，要截取的长度); or .substr(起始位置)</code></p><p><strong>长度</strong> <code>std::string.length();</code> 得到长度</p><p><strong>字符串比较</strong> <code>.compare()   比如： str.compare(&quot;abcd&quot;);</code> 大于返回正数，相等等于0；</p><p>扩展： <code>.compare(起始位置,参与比较的长度,被比较的字符串);</code></p><p><strong>字符串搜索</strong>  </p><p><code>.find()</code> 用来搜素字符串的内容,并返回内容所在的位置,当返回值是<code>std::string::npos</code>表示未找到</p><p><code>.find(要搜索的内容 , 开始搜索的位置)</code></p><p><code>.find(要搜索的内容,开始搜素的位置,要纳入的字符串长度[注:是搜索内容的字符串])</code></p><p><code>.rfind()</code> 用法和<code>find</code>一样,从字符串尾部<strong>倒叙搜索</strong></p><p><strong>插入字符串</strong></p><p><code>.insert()</code> 可以在一个string字符串的指定位置插入另一个字符串</p><p><code>.insert(要插入的位置 , 要插入的字符串)</code></p><p><code>.insert(要插入的位置,要插入的字符个数,要插入的字符)</code> exp:id.insert(3,6,’x’);</p><p><code>.insert(要插入的位置,要插入的字符串,要插入的字符串的起始位置,要插入的大小)</code></p><p><code>.insert(要插入的位置,要插入的字符串,要插入的大小)</code></p><p><strong>替换字符串</strong></p><p><code>.replace</code> 可以替换string字符串中的内容</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;)</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,&#39;字符&#39;)</code>对单字符</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,替换后内容节选长度[此处是替换的字符串的])</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;,替换后的起始位置,替换后内容的节选长度</code></p><p><strong>删除字符串</strong></p><p><code>`.erase()</code> 删除字符串中的内容</p><p><code>.erase(要删除的起始位置,要删除的起始长度)</code></p><p><code>.erase(要删除的起始位置)</code> exp: 从起始位置删除所有的内容</p><p><code>str.clear();</code></p><h3 id="指针数组字符串内存学习"><a href="#指针数组字符串内存学习" class="headerlink" title="指针数组字符串内存学习"></a>指针数组字符串内存学习</h3><p>{待补充}</p><p><strong>想得到放字符串这段内存的区域</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220311_164550.jpg" alt=""></p><p>不能修改!</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>exp：输入中文英文等字符串，正确返回字符个数</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012145.jpg" alt=""></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012436.jpg" alt=""></p><p>待补充</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>指针参数</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_025458.jpg" alt=""></p><p><strong>数组参数</strong></p><p>建议用数组方式引用</p><p><strong>引用参数</strong></p><p>指针可以传入nullptr，而引用不可以</p><p><strong>默认实参</strong></p><p>exp： <code>void func(int a,int&amp; b,int* c,bool x=true)</code></p><p>此时用户根据需要调用func时x可写可不写，不写默认是true</p><p>！<strong>默认实参只能放在最后</strong> 引用定义的时候不能瞎指</p><p><strong>不定量参数</strong></p><p><code>mian（int argc,char** argc）&#123;&#125;</code> C语言也常用</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_224012_edit_807927517925156.jpg" alt=""></p><p><strong>函数返回：返回指针和引用</strong></p><p>{知识很多 待补充}</p><p>比如返回结构体 ，返回指针，返回引用，传递引用参数时的类型转换</p><p>数组的引用：</p><p>exp： <code>int a[100]  int(&amp;b)[100]=a</code></p><p>传递数组引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> (&amp;array)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数：右值引用"><a href="#函数参数：右值引用" class="headerlink" title="函数参数：右值引用"></a>函数参数：右值引用</h2><p>ps：函数使用引用会节约内存消耗</p><p>左值就是一般左边定义的东西有明确的内存空间 可以读取写入，右值是存放在临时空间内</p><p>exp：<code>*(a+1)=2</code>  此事a+1仍然是一个右值</p><p><code>int&amp;&amp;</code> 右值引用 exp:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; e = <span class="number">100</span>+<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123; std::cout&lt;&lt;a; &#125;</span><br><span class="line"><span class="built_in">Add</span>(e+<span class="number">320</span>+<span class="number">329</span>);</span><br></pre></td></tr></table></figure><p>设计字符串类的时候会感受到…….</p><p>exp: 创建一个临时的角色信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">int</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role <span class="title">createmonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(Role&amp;&amp; rl)</span><span class="comment">//没有分配内存空间却达到了同样的效果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;rl.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220313_022431_edit_817161374477392.jpg" alt=""></p><h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><p>loading</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>可以指向特定类型函数的指针</p><p>函数返回类型 (*函数指针变量名)(参数类型 参数名称, ……参数类型 参数名称);</p><p><strong>转类型</strong> <code>char (*myadd)(int,int)=(char (*)(int,int)Add);</code></p><p>强转太长了怎么办: </p><p><code>typedef函数返回类型 (*函数指针变量名)(参数类型 参数名称,....参数类型 参数名称);</code></p><p>也可以: <code>using pfadd=char (*)(int,int);</code></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>C++有，c语言需要自己实现，不自带此功能</p><p>尽管函数名称相同,但是在我们调用函数时,通过函数参数的不同,编译器还是能够确定我们调用的是哪一个函数,因此程序能够准确的编译</p><p>！ 是参数的不同可以确定是哪个函数。 </p><p>但是编译器无法单纯通过返回值来确定你要返回的函数,参数要不同!</p><p>exp: <code>float ave()    和    int ave()</code>   无法重载</p><p>exp: 同样的函数,用指针和数组写法不能重载,引用也不行</p><p>Tips:为什么俩个函数,有一个int&amp; 一个float ,我定义了char变量去调用,强转为(int)x型,去调用函数却仍然是float函数,因为<strong>强转只是声明了一个临时的变量,而引用需要已经定义的(真实存在的)变量</strong></p><p>同样的函数,一个int 一个const int也不行(会出现歧义)</p><p>但是一个是int的引用int&amp;  一个是 const int&amp; 常量引用,那就可以重载</p><p>函数重载的时候不可以设置默认参数</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>除了类型不同外,函数的运算逻辑都一样,这样的函数我们就可以利用函数模板技术来生成对应的函数.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span><span class="comment">//ave求平均值的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于int ave(int a,int b)</span></span><br><span class="line"><span class="keyword">char</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于char ave(cahr a,char b)</span></span><br><span class="line">exp:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b,type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type1 a;<span class="comment">//可以定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以指定一个函数模板</span></span><br><span class="line">exp： ave&lt;<span class="keyword">int</span>&gt;(<span class="number">192.0f</span>,<span class="number">159.3f</span>); <span class="comment">// 执行int ave</span></span><br></pre></td></tr></table></figure><h3 id="函数模板和重载"><a href="#函数模板和重载" class="headerlink" title="函数模板和重载"></a>函数模板和重载</h3><p>函数模板的例外处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">float</span> <span class="title">ave</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b<span class="number">-100.0f</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">我们可以利用<span class="keyword">template</span>&lt;&gt;定义一种函数模板的例外情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数重载优先于函数模板,但是函数模板的例外情况要优先于函数重载</strong></p><p>函数模板的重载 函数模板的重载也是通过参数来区分</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="推断函数模板返回类型-多不同类型"><a href="#推断函数模板返回类型-多不同类型" class="headerlink" title="推断函数模板返回类型(多不同类型)"></a>推断函数模板返回类型(多不同类型)</h3><p>返回值,传入参数都不同</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时调用的时候可以 ave&lt;int,int&gt;();类似于这样强行更改类型</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">2</span>;</span><br><span class="line">M</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">bigger&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line">bigger&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//### 如何更加智能的推断-&gt; (c++14后)</span></span><br><span class="line">temp1ate &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以利用auto来推断返回值的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ab?a:b;)</span><br><span class="line">&#125;</span><br><span class="line">注*<span class="keyword">auto</span>做返回类型推断是在C++<span class="number">14</span>之后引入的</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b-&gt;<span class="keyword">decltype</span>(a&gt;b?a:b)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) bigger(type1 a,type2 b) <span class="comment">//decltype(auto)可以通过引用更改值</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//decltype(auto)为C++14后的写法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><h3 id="函数模板参数"><a href="#函数模板参数" class="headerlink" title="函数模板参数"></a>函数模板参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充 很多</span><br></pre></td></tr></table></figure><h3 id="函数模板本质"><a href="#函数模板本质" class="headerlink" title="函数模板本质"></a>函数模板本质</h3><p>待补充</p><h2 id="auto-and-decltype"><a href="#auto-and-decltype" class="headerlink" title="auto and decltype"></a>auto and decltype</h2><p>c++11之后出现</p><p>auto可以声明一个变量,让编译器根据变量的值来推断变量的类型</p><p>例如<br><code>auto a&#123;123&#125;;</code> 相当于<code>`int a&#123;123;</code> `<br>利用auto的这一特性我们可以利用auto来创建一个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">注*以上都并非<span class="keyword">auto</span>的最恰当用法,不管是函数还是变量,都不推荐使用<span class="keyword">auto</span>来声明</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>不能保留<span class="keyword">const</span>属性</span><br><span class="line">比如</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line">c是<span class="keyword">int</span>类型而非<span class="keyword">const</span>类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> 会优先推断为值类型而非引用类型</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; la=a;</span><br><span class="line"><span class="keyword">auto</span> d=a;</span><br><span class="line">d为<span class="keyword">int</span>类型而非<span class="keyword">int</span>&amp;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span>利用函数返回值来确定类型的时候,函数会执行</span><br><span class="line"><span class="keyword">auto</span> x=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//ave(1,2)会执行x的类型依据ave函数的返回类型来确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>会优先把值匹配成值类型而非引用类型,就以本例来说</span><br><span class="line">假设我们希望bigger函数返回的是<span class="keyword">int</span>&amp; 用<span class="keyword">auto</span>声明达不到这样的效果,为了达到这种目的,我们可以使用另外一种技术:  拖尾函数</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span>-&gt;<span class="keyword">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype关键字可以得出一个表达式的类型;</p><p>语法:decltype(表达式)<br><code>int a&#123;&#125;;</code><br><code>unsigned b;</code><br><code>decltype(a-b) x;相当于unsigned x;</code></p><p>如果decltype内的表达式没经历任何运算,那么得出的数据类型同表达式内的数据类型,并且<strong>decltype可以保留const和引用类型</strong> .</p><p>编译器依处理decltype关键字时的原则:</p><p>如果decltype内的表达式经历了运算,那么得出的数据类型是根据运算结果是否有固定的内存地址(左值)来决定的,如果有固定的内存地址则得出的类型为该类型的引用类型,如果没有固定的内存地址,则得出的类型为该结果的类型.</p><p>如果decltype内的表达式是一个函数,那么得出的数据类型是根据函数的返回类型来确定的;(decltype不会执行函数)</p><h2 id="static-only变量-and-inline"><a href="#static-only变量-and-inline" class="headerlink" title="static(only变量) and inline"></a>static(only变量) and inline</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>利用static可以声明一个静态变量    static类型变量名称;<br>例如:<br>static int a;<br>static的变量,如果没有指定初始化的值,那么会初始化为0,无论有没有指定初始值,都只会初始化一次!</p><p>exp: count不会只会在函数被初始化一次,生命周期很长,值会保留</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline int Add(int a,int b){<br>return a+b;<br>}<br>我们可以用inline声明一个内联函数<br>内联函数将会建议编译器把这个函数处理成内联代码以提升性能<br>始终是建议,具体编译器是否采纳,由编译器决定</p><p>[有些过时了]</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h2 id="函数一些理论"><a href="#函数一些理论" class="headerlink" title="函数一些理论"></a>函数一些理论</h2><h3 id="理解定义和声明"><a href="#理解定义和声明" class="headerlink" title="理解定义和声明"></a>理解定义和声明</h3><p>我们写的函数就是函数的定义</p><p>因为函数的定义是我们要告诉计算机具体如何来执行我们的命令,所以这个命令必须是明确的,你不能告诉它同时往东并且往右,这就说明我们编写代码的时候,你不能多次定义一个函数!<br>因此函数的定义只能有一次!<br>但是函数的声明是我们和编译器的对话,在某些特殊的场景下,我们可以多次声明一个函数!<br>虽然编译器觉得我们啰嗦,但是并不影响我们之前的感情。</p><p>声明的本质是与编译器的对话,单纯的声明并不存在内存的分配,只是给编译器一个大体的概念，既然是对话,我们可以多次对话,所以对于同一个事物,我们可以多次声明;<br>而定义的本质是要通过编译器与计算机对话,这就涉及到内存的分配和访问,因此同一事物,不管声明多少次,但是只能有一次定义;<br>变量其实也适用这个规则,我们可以通过关键字extern声明一个变量,而把变量的声明和定义分开;<br>我们写函数的声明的时候,没有写extern关键字,是因为函数的声明本身就是extern的,因此不需要我们手动指出;<br>extern 的作用也是告诉编译器,此处只是一个声明,你去别处找定义,因此extern是针对的全局变量，因为局部变量不存在去别U找的可能性!而函数的声明自带extern属性,因此函数本身也是全局的!<br>例如: <code>extern int a;</code></p><p>函数名是内存地址</p><h3 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h3><p>多个源码共用一个全局变量<br>在头文件中声明多个源文件中要共用的全局变量<br>察<br>比如<br><code>extern int verId;</code><br>至于verld的定义你可以放到任何源文件中,但是不可以放到头文件中,因为这样就违背了乎个事物只能定义一次的原则!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">放在头文件中的第一行,可以防止头文件被多次调用</span><br><span class="line"></span><br><span class="line">#ifndef</span><br><span class="line">#define</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="创建自己的SDK"><a href="#创建自己的SDK" class="headerlink" title="创建自己的SDK"></a>创建自己的SDK</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION <span class="meta-string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">namespace</span> my_sdk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Getversion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤:(vs环境) 做成静态库</p><p>右键属性-&gt;配置类型.静态库 .lib-&gt;右键属性 . 生成-&gt;打开文件夹 库做好了 .lib</p><p>使用时:<br>右键属性-&gt;包含目录 放入自己的lib-&gt;库目录 加入自己的.h目录-&gt; </p><p>几种方法: 1: <code>#pragma comment(lib,&quot;xxx.lib&quot;)</code>  </p><p>2: 右键属性-&gt;链接器-&gt;输入-&gt;附加依赖项(库目录需要有)</p><h3 id="创建项目类型"><a href="#创建项目类型" class="headerlink" title="创建项目类型"></a>创建项目类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 函数调用约定</span><br><span class="line"></span><br><span class="line">函数调用约定是函数调用与被调用者之间的一种协议,这个协议主要规定了以下两个内容:</span><br><span class="line"></span><br><span class="line">`如何传递参数` `如何恢复栈平衡`</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">函数调用约定_cdecl:</span><br><span class="line">__cdecl参数入栈顺序从右到左</span><br><span class="line">堆栈平衡:谁调用谁平衡</span><br><span class="line">正因为__cdecl这种堆栈平衡方式,能够支持不定量参数</span><br><span class="line"></span><br><span class="line">函数调用约定_stdcall</span><br><span class="line">___stdcall参数入栈顺序从右到左次</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">Windows编程中WINAPICA1LBACK都是__stdcall的宏</span><br><span class="line">生成的函数名会加下划线,后面跟@和参数尺寸</span><br><span class="line">int _stdcallave(int a, int b)</span><br><span class="line"></span><br><span class="line">函数调用约定__fastcall</span><br><span class="line">第一个参数通过ecs传递第二个参数通过edx传递</span><br><span class="line">剩余参数入栈顺序从右到左</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">fastcall的函数执行速度比较快</span><br><span class="line"></span><br><span class="line">_thiscall 用作C++中类的访问,我们将在类的底层时讲这种callnaked call是一个不常用的调用约定,一般用于实模式驱动开发</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>套娃&gt;&gt;&gt;</p><p>a调用b,b调用a称为互递归函数</p><p>递归会造成栈溢出</p><p>内联函数不能递归</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="转换单元"><a href="#转换单元" class="headerlink" title="转换单元"></a>转换单元</h3><p>我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include <xxx.h>)合并后,称为一个转换单元;<br>编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象);<br>最后<strong>链接器将各个转换单元的对象文件链接起来,生成我们的目标程序;</strong><br>比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误.</p><h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><p>即我们在编写代码中,C++标准未作规定的行为,称为未定义行为,未定义行为的结果是不确定的,具体在不同的编译器下会有不向的效果; 比如<br><code>c=2*a++ + ++a*6;</code><br>这里先算a++还是先算++a就是一个未定义行为<br>比如:<br><code>int x=-25602;×=x&gt;2;</code><br>x的结果在不同的编译器下是不确定的,因为这也属于未定义行为</p><h3 id="One-Definition-Rule"><a href="#One-Definition-Rule" class="headerlink" title="One Definition Rule"></a>One Definition Rule</h3><p><strong>单一性规则</strong></p><p>ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则;<br>但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C++20)在每个转换单元中都只允许有一个定义;非inline的函数或变量(C++17),在整个程序中,有且仅有一个定义;</p><p>总结: 有多个声明 , 只能有一个定义</p><h3 id="名称的链接属性"><a href="#名称的链接属性" class="headerlink" title="名称的链接属性"></a>名称的链接属性</h3><p>程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的;<br>链接属性分为以下三种:<br>内部链接属性:该名称仅仅在本转换单元中有效<br>外部链接属性:该名称在其他的转换单元中也有效<br>无链接属性:该名称仅仅能够用于该名称的作用域内访问</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A B</span></span><br><span class="line">将标识符A定义为B的别名</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>整数int</span></span><br><span class="line">整数a&#123;&#125;;</span><br><span class="line"></span><br><span class="line">取消定义： <span class="meta">#<span class="meta-keyword">undef</span></span></span><br><span class="line">    </span><br><span class="line">定义复杂表达式的宏：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(X,Y)  X+Y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVE(X,Y)  (X+Y)/2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIGGER(X,Y)  ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">AVE</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">BIGGER</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">#可以将一个标识符参数字符串化</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(X) std:cout&lt;&lt;#X <span class="comment">//字符串</span></span></span><br><span class="line"><span class="built_in">SHOW</span>(<span class="number">1234f</span>g);=&gt;std:cout&lt;&lt;<span class="string">&quot;12345fg&quot;</span></span><br><span class="line">##可以连接两个标识符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1(X,Y) void X##Y()&#123;std:cout&lt;&lt;#Y;&#125; <span class="comment">//连接字符串</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用#define 的方式定义常量并不安全.</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>有时候为了方便管理,把相关的函数,变量,结构体等会附加到一个命名空间中<br><code>namespace t  &#123;int value;&#125;</code><br>访问这个命名空间的变量<br><code>t:value</code></p><p>所有具有链接属性的对象,只要没有定义命名空间,就默认定义在<code>全局命名空间</code>中,全局命名空间中成员的访问不用显示的指定,当局部名称覆盖了全局名称时才需要显式的指定全局命名空间;<br><code>int a;  ::a=250</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局命名空间的扩展</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> weight &#123;<span class="number">1980</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> height&#123;<span class="number">1080</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">第二个htd属于对htd命名空间的扩展,weight和height同属一个命名空间</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间拓展</span></span><br><span class="line"><span class="function"><span class="keyword">namespace</span> htd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> htd:<span class="built_in">sendSms</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> hack</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> htd::hack::<span class="built_in">hackServer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">htd::sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未命名空间</span></span><br><span class="line">不给命名空间指定名称,将会声明一个未命名的命名空间</span><br><span class="line"><span class="keyword">namespace</span> &#123;&#125;</span><br><span class="line">未命名的命名空间中声明的内容一律为内部链接属性,包括用<span class="keyword">extern</span>声明的内容,未命名的命名空间仅仅在本转换单元中有效</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的别名</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer=htd::hack;</span><br><span class="line">hSever:<span class="built_in">hackServer</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预处理逻辑指令"><a href="#预处理逻辑指令" class="headerlink" title="预处理逻辑指令"></a>预处理逻辑指令</h2><p><code>#ifndef    #if    #elif</code></p><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//标准预定义宏</span><br><span class="line">__func__</span><br><span class="line">编译器支持ISO C99和ISO C++11指定的预定义标识符</span><br><span class="line">函数的名称</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025308.jpg" alt=""></p><p>//下面是微软公司做的宏</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025523.jpg" alt=""></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>为了方便调试,在编码风格上:</p><p>1 模块化<br>2 使用能够体现出具体意义的函数名和变量名</p><p>3 使用正确的缩进和代码块<br>4 良好的注释习惯</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充。。。</span><br></pre></td></tr></table></figure><h2 id="assert调试-（断言）"><a href="#assert调试-（断言）" class="headerlink" title="assert调试 （断言）"></a>assert调试 （断言）</h2><p>语法:<br>assert(bool表达式);<br>如果括号内的bool表达式为false<br>则会调用std:abort()函数<br>弹出对话框<br>assert宏需要头文件 cassert </p><p>可以通过 <code>#define NDEBUG</code> 关闭 要放在include前</p><p>static_assert用于编译时检查条件<br>static_assert(bool表达式,”错误信息”);<br>C++17新语法：<br>static_assert(bool表达式);<br>与assert不同,static_assert主要是用来在编译时检查重要的条件</p><p>因此检查的bool表达式中,只能用于常量</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164728551916780271586411%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164728551916780271586411&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81913729.142^v2^pc_search_insert_es_download,143^v4^control&amp;utm_term=stl&amp;spm=1018.2226.3001.4187">STL介绍</a></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>00P(Object Oriented Programming)即面向对象编程,本质上是一种编程思想,通过把我们编程中遇到的事物来抽象成对象来编程;与OOP相关的还有OOD(面向对象设计),00A(面向对分析)等;<br>OOP应当遵循OOD的原则,所有坏的OOP代码基本都是违反了OOD原则</p><p>SOLID原则 { 待百度 }</p><h3 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h3><p>封装：</p><p>继承：</p><p>多态：</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//影响后面出现的内容 只能类中使用</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hpRecover;-&gt;&gt;成员变量</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> -&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">hpRecover=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> hp;-&gt;&gt;成员变量</span><br><span class="line"><span class="keyword">int</span> damage; -&gt;&gt;成员变量</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span>-&gt;&gt;成员函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">role.hp-=damage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;<span class="comment">//外部定义后需要定义成这样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROLE::Act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>空class默认一个内存空间</p><p>inline成员函数： （推荐写在头文件里）</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数的指针 ， 代表定义的成员本身</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Role::GetHP</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const对象只能调用const成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const对象不能以任何方式改变,这是const的原则,在这个基本原则下,产生了一些列效应,比如const对象只能调用const成员函数; const对象无法调用别的成员<br>另外一个我们不注意的变化是,在const成员函数下,this指针也变成了const指针</p><p><strong>const类型转换</strong></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_174156.jpg" alt=""></p><p><strong>mutable</strong></p><p>mutable声明的成员变量可以被const成员函数修改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> getHPCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> GetHP0 <span class="keyword">const</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Role:GetHP0 <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">getHPCont++;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在类的定义中有一种特殊的成员函数叫做构造函数.构造函数在类被创建时自动被调用,一般用来创建新的类实例时执行初始化操作构造函数与它所在的类同名,并且没有返回值,任何类都至少有一个构造函数;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hpRecover;</span><br><span class="line"><span class="keyword">void</span> lnit0</span><br><span class="line">&#123;</span><br><span class="line">hpRecover=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ROLE</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">int</span> damage;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>&#123;</span><br><span class="line">role.hp-=damage;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//跟java一样 ， 构造函数和类同名</span></span><br><span class="line">如果什么都不做 推荐<span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>被explicit关键字修饰的构造函数会禁用类型转换</p><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ROLE</span>(<span class="keyword">int</span> _lv,<span class="keyword">int</span> _damage):lv&#123;_lv&#125;, damage&#123;_damage&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>初始化时，初始化可以这样写快速初始化</p><p>效率更高，有时候只能这样去初始化</p><p><strong>使用成员初始化列表这样的方式构造类,要注意一个问题,即为成员赋值的顺序不是依据代码的顺序,而是成员变量在类的出现顺序;</strong></p><p><strong>委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</strong></p><p><code>ROLE(int _lv,int xx):ROLE(_lv)</code> 这种是委托构造，关于lv的都在ROLE这个构造函数里</p><p>副本构造函数</p><p>编译器为类指定了一个默认的副本构造函数,我们也可以手动指定副本构造函数</p><p><code>Role role1;   Role role2(role1);</code></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在类中还有一种特殊的成员函数,叫做析构函数,析构函数在类的生命周结束时,被自动调用,一般用来做 扫尾工作 比如释放内存,关闭句柄等等,如果一个类没有定义析构函数,那么编译器会自动添加一个空的析构函数,析构函数只能有一个;<br>析构函数没有参数,没有返回类型,一般不会手动调用,如果类的析构函数为空,最好使用关键字default来定义,例如:<br><code>~ROLE()=default;</code></p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>我们可以在类中通过static关键字声明一个类的静态成员变量,类的静态成员变量的特点:<br>1 所有类的实例中,共享类中的静态成员变量</p><p>2 类的静态成员变量在没有类的实例的情况下,依然可以访问</p><p>3 类的静态成员变量并不完全属于类 内存空间不属于类</p><p>实例类不管多少个，static都不变，被所有实例共享一个内存空间</p><p>c++17后 可以 <code>inline static int count&#123;20&#125;</code> 来定义</p><p><code>const static int count&#123;20&#125;</code></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>我们可以利用static关键字声明一个类的静态成员函数,类的静态成员函数有如下特点:</p><p>(1)不管有没有创建类的实例,都可以访问类的静态成员函数<br>(2类的静态成员函数不能访问非静态的成员变量<br>(3)类的静态成员函数不能是const<br>(4)类的静态成员函数不能使用this指针</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">可以通过<span class="keyword">friend</span>关键字声明一个函数为某个类的友元函数,友元函数可以访问该类中的所有成员</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetHP</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t.<span class="built_in">ResetHP</span>();</span><br><span class="line">t.hp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>俩个类交朋友的话 在另一个类上面声明 <code>class 类名</code> 即可</p><p>友元 不建议用</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>把一个类写在一个类里</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line"><span class="keyword">int</span> mp;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line">我们可以在类的声明中再声明一个类,在类中声明的类称为嵌套类,而声明嵌套类的类称为外层类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>作用域</strong></p><p>嵌套类的声明在外层类中,因此嵌套类的作用域受外层类限定</p><p>假如要在类外声明女个Weapon对象<br><code>Role::Weapon mWpon;</code><br>嵌套类的作用域受封装属性管辖,即private封装的嵌套类是无法在类外使用的</p><p><strong>在类外定义嵌套类</strong></p><p><code>class ROLE::Weapen</code> 在外的类要这么写 。  函数、对象同理</p><p>函数指针情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span>;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>:</span>:Weapon&#123;</span><br><span class="line"><span class="function">Weapon*<span class="title">CreateWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">CreateWeapon</span>()&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嵌套类可以访问外层类的所有成员<br>外层类仅能访问嵌套类的公有成员</p><p><strong>局部类</strong></p><p>定义在函数内的类称为局部类</p><p>局部类的定义必须写在类内</p><p>局部类中不允许使用静态成员变量</p><p>局部类可以访问全局变量</p><p><strong>嵌套类模块化问题</strong></p><p>多文件时。嵌套头文件，类出错  注意头文件</p><h2 id="类的成员函数的函数指针"><a href="#类的成员函数的函数指针" class="headerlink" title="类的成员函数的函数指针"></a>类的成员函数的函数指针</h2><h2 id="从底层理解类（逆向）"><a href="#从底层理解类（逆向）" class="headerlink" title="从底层理解类（逆向）"></a>从底层理解类（逆向）</h2><p>{待补充}</p><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>在OOP编程中,万物皆对象,我们如何让这些对象也能够像普通类型一样实现加减乘除呢?比如我们学习过的std:string对象<br><code>std:string str=&quot;大家好!&quot;;</code><br><code>str=str+”才是真的好!&quot;;</code><br>要实现这个功能我们就要对运算符+重新进行设计,当我们的对象进行+运算时不再是编译器默认的+预算,而是进入我们指定的函数,这种重新设计运算符规则的技术就称为运算符重载!<br>语法:<code>返回类型operator运算符0</code><br>//例如 <code>bool operator&lt;(const Role&amp; role);</code></p><p>非类成员函数实现需要使用友元定义</p><p>即： <code>man&lt;woman == man.operator&lt;(woman) == man&lt;woman</code></p><h3 id="原则和时机"><a href="#原则和时机" class="headerlink" title="原则和时机"></a>原则和时机</h3><p><strong>意义</strong></p><p>(1）让类也支持原生的运算比如＋-*/<br>(2）提升对程序的控制权比如重载new delete newdelete[<br>备注:<br>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率</p><p><strong>限制</strong></p><p>(1)不能自创运算符比如=== ,=&lt;&gt;=只能重载现有运算符</p><p>(2)以下运算符不能重载<br>(a)对象访问运算符．例如 user.hp</p><p>(b)作用域解析运算符::例如std::cout</p><p>(c)求大小的运算符sizeof 例如sizeof(int)</p><p>(d)条件运算符?:例如b=a&gt;c?100:200<br>(3)不能修改运算符本身的优先级,相关性<br>(4)在C++17后，也不能修改运算符的操作数的计算顺序，在C++17前，编译器可以自由选择如何计算（未定义行为)</p><p>(5)除了delete/delete和new/new外,不能对原生数据类型的其他运算符进行重载，比如把char类型的+定义为-</p><p>(6)除了new和delete以为，其他运算符的arity(运算符关联的操作数的个数或者是关联的参数）一律不能修改</p><p><strong>原则</strong></p><p>(1)不要改变运算符本身的意义,比如把加法重载为减法<br>(2)不建议重载逻辑运算符&amp;&amp; ||,取址运算符&amp; 逗号运算符，<br>备注:重载后的逻辑运算符将不会进行短路测试，在C++17标准前，编译器可以自由决定先计算左操作数还是右操作数,在C++17后计算的顺序规定为先计算左再计算右</p><p><strong>语法</strong><br>二元运算符的重载<br>利用全局函数<br><code>返回类型 operator 运算符(类型 左操作数,类型 右操作数）</code><br>利用类的成员函数<br><code>返回类型 operator 运算符(类型 右操作数)</code><br>一元运算符的重载<br>利用全局函数返回<br><code>返回类型 operator 运算符(类型 操作数)</code><br>利用类的成员函数<br><code>返回类型 operator 运算符()</code></p><p>有的运算符只能重载为类的成员函数,有些运算符只能重载为全局函数,有些运算符既可以重载为类的成员函数又可以重载为全局函数,如果一个运算符既可以重载为成员函数又可以重载为全局函数,我们一般推荐重载为类的成员函数,因为类的成员函数可以是虚函数,单全局函数不能是虚函数,如果这个运算符不修改对象,应该将这个成员函数限定为const<br>运算符重载的参数一般可以传递值或者引用,大部分情况下,能够传递引用就不要传递值,对于不会修改的值最好是限定为const,某些时候要擅用使用右值引用&amp;&amp;作为参数<br>运算符重载的返回值一般来说可以是任何类型,但是尽量要符合运算符的原意,比如把&gt;运算符返回指针类型,把+返回bool类型,都不是很好的选择</p><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>{待补充}</p><p>很多符号</p><h2 id="重载类型转换"><a href="#重载类型转换" class="headerlink" title="重载类型转换"></a>重载类型转换</h2><p>1 类型转换运算符只能重载为类的成员函数</p><p>2 类型转换运算符没有返回值。它的返回值由类型转换的类型来决定</p><p>3 语法 ``</p><p>4 <code>operator 类型() const</code></p><p>{待补充}</p><p><code>什么是隐试类型转换： float x=2  此时2是int型 这是就是隐式类型转换转成float型</code></p><h2 id="重载内存分配"><a href="#重载内存分配" class="headerlink" title="重载内存分配"></a>重载内存分配</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>假设有一个类animal现在我们基于animal类创造一个新类monkey,那么我们说类animal</p><p>monkey类的基类(父类),moneky类是anima类的派生类(子类),子类自动继承包含了父类的成员变量以及成员函数!</p><p>子类不能继承父类的构造函数,析构函数,重载赋值运算符,虽然不能继承,但是这些内容依然是存在于父类中的。</p><p>如果我们继续基于monkey创造一个新类bigMonkey,那么monkey是bigMonkey的直接基类,animal是bigMonkey的间接基类</p><p><code>class 类名:访问属性[public|private|protected] 父类名称</code></p><p>protected: 只有子类和友元可以访问</p><p>不想被别人继承的话 后面加 <code>final</code></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220316202707.png" alt=""></p><p><strong>修改继承成员的访问属性</strong></p><p>可以用<code>using 基类名::成员名</code> 来修改继承来的成员的访问属性</p><p><strong>使用proteted和private访问属性有几个好处</strong></p><p>可以更好的封装父类成员</p><p>可以在子类作为基础进行派生类的时候提供继承控制</p><p>将保护属性为private的父类产生的子类作为基类的时候,派生类继承但不能访问构建其父类的基类成员</p><p>将保护属性为protected的父类产生的子类作为基类的时候,派生类继承且可以访问其非私有成员</p><p><strong>继承访问属性的选择</strong></p><p>一般来说,尽量射击类的成员变量为private,如果需要访问这些成员变量,应该提供setter以及getter函数</p><h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p><strong>派生类</strong></p><p>构造顺序:先构造基类再构造派生类 (父亲-&gt;儿子)</p><p><strong>父本构造函数</strong></p><p>一个由另一个来复制.  执行时就不会调用原本的构造函数了</p><p>exp: <code>actObject(const actObject&amp; obj)</code></p><p><strong>继承构造函数</strong></p><p>通过 <code>using 基类::基类构造函数</code> 可以继承基类构造函数,但是默认构造函数与副本构造函数不会被继承</p><h2 id="继承析构函数"><a href="#继承析构函数" class="headerlink" title="继承析构函数"></a>继承析构函数</h2><p>先释放派生类,再释放基类  , 与构造顺序相反</p><p>当基类和派生类的成员函数同名时,要分俩种情况:</p><p>1 函数名相同,参数不同  <code>using 基类::函数名</code></p><p>2 函数名相同,参数相同 <code>基类::函数名</code></p><p>exp: <code>obj.lastObject::lastlastObject::show();</code></p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>一个类可以拥有多个父类,并且可以继承各个父类的成员 (不推荐用)</p><p><code>class xx: public x1 , public x2 &#123;&#125;;</code></p><p><strong>多重继承带来的重复继承问题</strong></p><p>问题时继承来的东西重复继承</p><p>首先可以强制指定解决√</p><p>另一方法: <strong>虚基类</strong>  <code>class xx:public virtual x&#123;&#125;;</code></p><p>意思时只引入一次,第二次不引入</p><h2 id="内存角度理解"><a href="#内存角度理解" class="headerlink" title="内存角度理解"></a>内存角度理解</h2><p>{深入理解 待补充}</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="对象多态"><a href="#对象多态" class="headerlink" title="对象多态"></a>对象多态</h2><p>exp: 人是动物√  动物是人×  </p><p>即第一个第向上转型(父类=&gt;子类 父类表达子类), 第二个是向下转型(子类=&gt;父类 子类表达父类)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    peole  lz;</span><br><span class="line">    lz.age = <span class="number">22</span>;</span><br><span class="line">    lz.monry=<span class="number">1</span>;</span><br><span class="line">    animal* anm1=&amp;lz;</span><br><span class="line">    people* humn=(people*)anm1;</span><br><span class="line">    <span class="comment">//不推荐这样用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存切片</strong></p><p>exp: 人类转成动物类的时候, 有些东西会丢掉(比如钱), 这就是内存切片</p><h3 id="对象多态详解"><a href="#对象多态详解" class="headerlink" title="对象多态详解"></a>对象多态详解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moveobj</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monstermove</span>:</span><span class="keyword">public</span> moveobj</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">monstermove monster;</span><br><span class="line">moveobj* _move=&amp;monster;<span class="comment">//隐式类型转换 向上转型</span></span><br><span class="line"></span><br><span class="line">monstermove* _pmove=&amp;_move; <span class="comment">//隐式 向下转型 不允许!  可以强制</span></span><br><span class="line">monstermove* _pmove=(monstermove*)_move;</span><br><span class="line">monstermove* _pmove=<span class="keyword">static_cast</span>&lt;monstermove*&gt;_move; <span class="comment">//会检测</span></span><br><span class="line">待补充...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="动态强制转换"><a href="#动态强制转换" class="headerlink" title="动态强制转换"></a>动态强制转换</h3><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220317_022820.jpg" alt=""></p><p>只能用于多态类</p><h2 id="方法多态-多态类"><a href="#方法多态-多态类" class="headerlink" title="方法多态(多态类)"></a>方法多态(多态类)</h2><p><strong>静态多态</strong> </p><p>①函数重载  <code>函数(&amp;类实例化的对象)</code> 从而判断执行哪一个函数</p><p>②函数模板</p><p><strong>动态多态</strong></p><h3 id="virtual虚函数"><a href="#virtual虚函数" class="headerlink" title="virtual虚函数"></a>virtual虚函数</h3><p>告诉派生类 我这个函数是虚的 你需要重写</p><p>virtual 放在定义函数的前面</p><p><strong>使用条件</strong></p><p>virtual只能写在类的内部声明或者定义,不能把virtual写在类的外部定义中</p><p>调用类的对象是无法使用虚函数的,必须使用基类指针来实现虚函数的调用</p><p>虚函数在派生类和基类中必须具有相同的及参数列表</p><p>虚函数在派生类和基类中返回值要求基本一致,但是当返回类型为类类型的指针和引用时除外</p><p>虚函数不能是函数模板</p><p><code>类名* 函数名() override</code> 代表我这个函数是继承来的</p><p>final 代表不再被继承.</p><ul><li><p>虚函数的执行也是遵循类的生成和销毁的(自我理解)</p></li><li><p>可以使用 <code>基类::基类函数()</code> 强行调用基类函数</p></li><li><p>默认实参在基类已经定义了那么派生类的修改是无效的,即使执行派生类的函数</p></li><li>当你通过基类声明派生类对象 <code>基类* p=new 派生类();</code> 然后释放内存调用析构函数的时候,调用的是基类的析构函数(因为派生函数不是虚函数,你是通过基类声明的对象)  容易造成内存泄漏,所以需要 进行 虚析构函数 , 即可正常.</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>在实际的项目设计中,可能出现一种情况,父类有N个派生类<br>比如Animal类派生出Dog和Cat<br>此时我们在Animal类中是无法确定Move函数的内容的,这个时候为Animal类设计Move函数的内容是无意义的,这种情况下我们可以将Move函数设计为纯虚函数<br><code>void virtual Move(=0;</code><br>=0可以将指定的函数设置为纯虚函数</p><p><strong>为什么要定义成纯虚函数</strong>  为了利用它的多态性,实现多态</p><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>有纯虚函数的类  不能用于实体</p><p>拥有纯虚函数的类称为抽象类,因为该类的函数没有实现,因此不能创建抽象类的实例,但是却可以使用抽象类的指针和引用作为返回或者参数!<br>抽象类的构造函数因为不能实际使用,所以一般推荐把抽象类的构造函数定义为protected<br>抽象类的派生类如果没有定义纯虚函数,则该派生类依然是抽象类</p><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p>类中所有(极大部分)函数定义为纯虚函数的类成为接口类</p><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p><code>typeid(类型).name</code></p><p>输出类型名字 但是必须要有多态</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>c++ 的基础还是有些没有总结好,后面补充</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 菜鸡学习❀ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯面试</title>
      <link href="/2022/02/16/tx1/"/>
      <url>/2022/02/16/tx1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><p>[TOC]</p><p>总结中。。。好好学习</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸡学习❀ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04美化</title>
      <link href="/2022/02/13/Ubuntu%E7%BE%8E%E5%8C%96/"/>
      <url>/2022/02/13/Ubuntu%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>主题<a href="https://www.pling.com/s/Gnome">https://www.pling.com/s/Gnome</a><br>扩展<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="登陆-Ubuntu-账号，开启-Livepatch-功能"><a href="#登陆-Ubuntu-账号，开启-Livepatch-功能" class="headerlink" title="登陆 Ubuntu 账号，开启 Livepatch 功能"></a>登陆 Ubuntu 账号，开启 Livepatch 功能</h2><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/image-20220214041014784.png" alt="image-20220214041014784"></p><p>点击 Ubuntu Single-On 就会弹出登陆页面了，这里也可以先不登陆，直接点击跳过，后面再登陆。</p><p>也可以通过在已安装软件列表里面搜索 Software &amp; Updates 软件，如下图，打开后登陆 Ubuntu 账号。</p><p>这里有问题,先不看</p><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h3 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions</span><br><span class="line"></span><br><span class="line">删掉原来的ubuntu-dock (emmmm)</span><br><span class="line">sudo apt-get autoremove --purge gnome-shell-extension-ubuntu-dock -y</span><br></pre></td></tr></table></figure><p>用浏览器打开扩展插件商店，地址：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/image-20220218224807211.png" alt="image-20220218224807211"></p><p>下载主题McMojave <a href="https://www.gnome-look.org/p/1275087/">https://www.gnome-look.org/p/1275087/</a></p><p>icon theme <a href="https://www.gnome-look.org/s/Gnome/p/1348081">https://www.gnome-look.org/s/Gnome/p/1348081</a></p><p>自己找 然后解压放在/usr/share/themes和icons下面</p><p>然后在gnome里面使用就可以</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS1 Noetic</title>
      <link href="/2022/02/05/ros-1/"/>
      <url>/2022/02/05/ros-1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">如何移植别人的工程:</span><br><span class="line">在根目录 catkin_make 后 ,会报错,然后修改的地方在build里,需要更改Cmake.txt以及 Makefile ,再补上所需要的依赖,就可以了</span><br><span class="line">安装依赖:</span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #自己修改</span><br><span class="line">rosdep install --from-paths ~/catkin_ws/src --ignore-src -r</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h1 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="常见操作指令"><a href="#常见操作指令" class="headerlink" title="常见操作指令"></a>常见操作指令</h1><p><strong>查找：</strong><br>rosc/roscd：切换当前工作目录到ros的某个程序包<br>rosls：按程序包的名称执行ls命令<br>catkin_ctreate_pkg：创建功能包<br>catkin_make：编译ROS工作空间，该src空间下所有程序包以及其子包都会被编译</p><p>-</p><p>roscore：启动管理器<br>rosrun：运行ROS程序包中的可执行文件<br>roslaunch：启动roscore，本地结点和远程结点，设置服务器参数（ssh）<br>roslaunch package_name filename.launch：启动包中的一个文件<br>rospack：获取程序包有关信息<br>rospack find：返回程序包的路径<br>rospack list：获取所有的程序包<br>rosdep：rosdep install package_name 可以下载安装ROS 程序包所需要的系统依赖项<br>roswtf：可以检查ROS系统并尝试发现问题<br>rostopic -h：查看所有Topic操作<br>rostopic list：获取所有的Topic列表<br>rosrun rqt_plot rqt_plot：图形化显示Topic<br>rostopic echo ‘topic namae’：查看某个Topic的信息</p><h1 id="video"><a href="#video" class="headerlink" title="video"></a>video</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg usb_cam std_msgs roscpp cv_bridge sensor_msgs image_transport</span><br><span class="line">    </span><br><span class="line">img_publisher.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_publisher&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Publisher pub = it.<span class="built_in">advertise</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  cv::VideoCapture cap;</span><br><span class="line">  cv::Mat frame;</span><br><span class="line">  <span class="keyword">int</span> deviceID=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">deviceID=argv[<span class="number">1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> apiID=cv::CAP_ANY;</span><br><span class="line">  cap.<span class="built_in">open</span>(deviceID+apiID);</span><br><span class="line">  <span class="keyword">if</span>(!cap.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">std::cerr&lt;&lt;<span class="string">&quot;ERROR! Unable to open camera&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">cap.<span class="built_in">read</span>(frame);</span><br><span class="line"><span class="keyword">if</span>(!frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, frame).<span class="built_in">toImageMsg</span>();</span><br><span class="line">pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_viewer.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">imageCallback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;view&quot;</span>, cv_bridge::<span class="built_in">toCvShare</span>(msg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (cv_bridge::Exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;</span>, msg-&gt;encoding.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_viewer&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  cv::<span class="built_in">startWindowThread</span>();</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Subscriber sub = it.<span class="built_in">subscribe</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">  $&#123;OpenCV_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">add_executable</span>(img_publisher src/img_publisher.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(img_viewer src/img_viewer.cpp)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_publisher $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_viewer $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;build_depend&gt;opencv2&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;opencv2&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;opencv2&lt;/exec_depend&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic">https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic</a></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸡学习❀ </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础再学习</title>
      <link href="/2022/02/01/C++1/"/>
      <url>/2022/02/01/C++1/</url>
      
        <content type="html"><![CDATA[<p>C++基础再学习<br>PS:之前学了一点,不过只在opencv简单使用,算法题和面试题,包括ROS等,随着python的不断壮大,python似乎是更好用的工具.不过C++还是挺重要的,对于嵌入式领域还是需要的.</p><p>[TOC]</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><p>创建枚举，需要使用关键字 enum。枚举类型的一般形式为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span> </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><br>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p><p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure><br>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br><code>enum color &#123; red, green=5, blue &#125;;</code><br>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container"><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>const</td><td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr><tr><td>volatile</td><td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td></tr><tr><td>restrict</td><td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr></tbody></table></div><h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h1><h2 id="auto-c-17开始弃用"><a href="#auto-c-17开始弃用" class="headerlink" title="auto(c++17开始弃用)"></a>auto(c++17开始弃用)</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h2 id="register-c-17开始弃用"><a href="#register-c-17开始弃用" class="headerlink" title="register(c++17开始弃用)"></a>register(c++17开始弃用)</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><p><code>&#123;   register int  miles; &#125;</code></p><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h2 id="static存储类"><a href="#static存储类" class="headerlink" title="static存储类"></a>static存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/image-20220203045316505.png" alt=""></p><h2 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p>第一个文件：main.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件：support.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure><p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./write</span><br><span class="line">Count is 5</span><br></pre></td></tr></table></figure><h2 id="mutable存储类"><a href="#mutable存储类" class="headerlink" title="mutable存储类"></a>mutable存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象.它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h2 id="thread-local-C-11-存储类"><a href="#thread-local-C-11-存储类" class="headerlink" title="thread_local (C++11)存储类"></a>thread_local (C++11)存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值可以表示为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure><p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p><p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>其实，不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table></div><p><code>#include  &lt;cstring&gt;</code></p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>关于面向对象:</p><p>exampl:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">   string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">   string str3;</span><br><span class="line">   <span class="keyword">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str3 : runoob</span><br><span class="line">str1 + str2 : runoobgoogle</span><br><span class="line">str3.size() :  12</span><br></pre></td></tr></table></figure><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p><strong>和指针的区别:</strong></p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="keyword">int</span>    i;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="keyword">int</span>&amp;    r = i;</span><br><span class="line">   <span class="keyword">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p><div class="table-container"><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">把引用作为参数</a></td><td style="text-align:left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">把引用作为返回值</a></td><td style="text-align:left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td></tr></tbody></table></div><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><div class="table-container"><table><thead><tr><th style="text-align:left">头文件</th><th style="text-align:left">函数和描述</th></tr></thead><tbody><tr><td style="text-align:left"><iostream></td><td style="text-align:left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td style="text-align:left"><iomanip></td><td style="text-align:left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td style="text-align:left"><fstream></td><td style="text-align:left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table></div><p><strong>延申待补充……</strong></p><h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><h1 id="C-高级"><a href="#C-高级" class="headerlink" title="C++高级"></a>C++高级</h1>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 菜鸡学习❀ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习途中小Tips</title>
      <link href="/2022/01/10/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/01/10/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="About-Vim"><a href="#About-Vim" class="headerlink" title="About Vim"></a>About Vim</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">批量替换:</span><br><span class="line">:%s/abc/123/g </span><br><span class="line">-</span><br><span class="line">选中 单词开头或者结尾 (在v模式下) 按e进行选择</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><p><strong>替换github.com 为 hub.fastgit.org</strong></p><p><strong>重新连接Ubuntu联网指令：</strong></p><p><code>sudo /etc/init.d/network-manager restart</code></p><p><strong>重新挂载共享文件夹</strong></p><p><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code></p><p><strong>搜wifi:</strong></p><p><code>sudo iw dev wlan0 scan | grep SSID</code> </p><p><strong>交叉编译树莓派gcc：</strong></p><p><code>arm-linux-gnueabihf-gcc</code></p><p><strong>树莓派安全关机：</strong></p><p><code>sudo shutdown -h now</code></p><p><strong>树莓派重启：</strong></p><p><code>sudo reboot</code><br><strong>树莓派传输文件使用fillzeila：前面加上sftp://</strong></p><p><strong>树莓派拍照：</strong> <code>raspistill -o image.jpg</code><br>监控   :8080</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装软件：sudo  dpkg  -itar xvf xxx</span><br><span class="line">Linux查看pdf：zathura`</span><br><span class="line">LINUX解压文件：tar xvf xxx</span><br></pre></td></tr></table></figure><h3 id="摄像头推流："><a href="#摄像头推流：" class="headerlink" title="摄像头推流："></a>摄像头推流：</h3><p><code>/usr/local/bin/mjpg_streamer -i &quot;/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720&quot; -o &quot;/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot;</code></p><p><strong>临时路径：</strong></p><p><code>export LD_LIBRARY_PATH=/home/lz/face/samplecode/ASFTestDemo/linux_so/:$LD_LIBRARY_PATH</code> </p><p><strong>opencv:</strong><br>    编译时 加 <code>pkg-config --cflags --libs opencv</code></p><p><strong>Windows pip install</strong></p><p><code>pip install 包名 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</code></p><h3 id="百度文库下载"><a href="#百度文库下载" class="headerlink" title="百度文库下载:"></a>百度文库下载:</h3><p>网址baidu后面加三个v </p><p>继续补充…</p><p><strong>Typora+七牛云配置:</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 存储空间名</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义域名</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span>:  <span class="string">&quot;&quot;</span>, <span class="comment">// 存储区域编号</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 网址后缀，比如？imgslim</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;img/&quot;</span> <span class="comment">// 自定义存储路径，比如 img/</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 小提示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客常用配置</title>
      <link href="/2022/01/01/hello-world/"/>
      <url>/2022/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Front-matter 是markdown 文件最上方以 —- 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于頁面配置<br>Post Front-matter 用于文章頁配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000604.png" alt=""></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:缩略图</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br><span class="line">another:::::::::::::::::::</span><br><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">author: </span><br><span class="line">img: /medias/banner/7.jpg</span><br><span class="line">coverImg: /medias/banner/7.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">toc: true</span><br><span class="line">password: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110</span><br><span class="line">mathjax: true</span><br><span class="line">summary: 自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- </span><br><span class="line">categories:</span><br><span class="line">- </span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000809.png" alt=""></p><h3 id="新-md"><a href="#新-md" class="headerlink" title="新.md"></a>新.md</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Copyright-beautify # 文章名称</span><br><span class="line">date: 2021-03-02 13:52:46 # 文章发布日期</span><br><span class="line">updated: 2021-03-02 13:52:46 # 文章更新日期</span><br><span class="line">copyright_author: Nesxc # 作者覆写</span><br><span class="line">copyright_url: #https://www.nesxc.com/post/hexocc.html # 原文链接覆写</span><br><span class="line">license: # 许可协议名称覆写</span><br><span class="line">license_url: # 许可协议链接覆写</span><br><span class="line">author: </span><br><span class="line">img: </span><br><span class="line">coverImg: </span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">toc: true</span><br><span class="line">mathjax: false</span><br><span class="line">password:</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">sticky: 1 #置顶用 越大置顶优先级越大</span><br><span class="line">aside: false&lt;-- 关闭侧边栏</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建日期</span><br><span class="line">updated: 更新日期</span><br><span class="line">cover: 文章封面</span><br><span class="line">description: 文章描述</span><br><span class="line">swiper_index: 1 #置顶轮播图顺序，需填非负整数，数字越大越靠前</span><br><span class="line">comments: false #关闭评论</span><br><span class="line">subtitle: 左上角显示</span><br><span class="line">description: 提示-&gt;左上角</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>给 js 脚本加上 <code>defer</code> 和 <code>ansyc</code> 属性来实现异步加载，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">https://unpkg.zhimg.com/vue@2.6.11&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/zjwo/CDN/js/pyq/pyq.min.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Boke相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
