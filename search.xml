<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++基础再学习</title>
      <link href="/2022/02/01/C++1/"/>
      <url>/2022/02/01/C++1/</url>
      
        <content type="html"><![CDATA[<p>C++基础再学习<br>PS:之前学了一点,不过只在opencv简单使用,算法题和面试题,包括ROS等,随着python的不断壮大,python似乎是更好用的工具.不过C++还是挺重要的,对于嵌入式领域还是需要的.</p><p>[TOC]</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><p>创建枚举，需要使用关键字 enum。枚举类型的一般形式为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span> </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><br>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p><p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure><br>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br><code>enum color &#123; red, green=5, blue &#125;;</code><br>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container"><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>const</td><td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr><tr><td>volatile</td><td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td></tr><tr><td>restrict</td><td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr></tbody></table></div><h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++存储类"></a>C++存储类</h1><h2 id="auto-c-17开始弃用"><a href="#auto-c-17开始弃用" class="headerlink" title="auto(c++17开始弃用)"></a>auto(c++17开始弃用)</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h2 id="register-c-17开始弃用"><a href="#register-c-17开始弃用" class="headerlink" title="register(c++17开始弃用)"></a>register(c++17开始弃用)</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><p><code>&#123;   register int  miles; &#125;</code></p><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h2 id="static存储类"><a href="#static存储类" class="headerlink" title="static存储类"></a>static存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.lizheblogs.xyz//post/image-20220203045316505.png" alt=""></p><h2 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p>第一个文件：main.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件：support.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure><p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./write</span><br><span class="line">Count is 5</span><br></pre></td></tr></table></figure><h2 id="mutable存储类"><a href="#mutable存储类" class="headerlink" title="mutable存储类"></a>mutable存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象.它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h2 id="thread-local-C-11-存储类"><a href="#thread-local-C-11-存储类" class="headerlink" title="thread_local (C++11)存储类"></a>thread_local (C++11)存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值可以表示为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure><p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p><p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>其实，不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table></div><p><code>#include  &lt;cstring&gt;</code></p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>关于面向对象:</p><p>exampl:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">   string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">   string str3;</span><br><span class="line">   <span class="keyword">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str3 : runoob</span><br><span class="line">str1 + str2 : runoobgoogle</span><br><span class="line">str3.size() :  12</span><br></pre></td></tr></table></figure><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p><strong>和指针的区别:</strong></p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="keyword">int</span>    i;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="keyword">int</span>&amp;    r = i;</span><br><span class="line">   <span class="keyword">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p><div class="table-container"><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">把引用作为参数</a></td><td style="text-align:left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">把引用作为返回值</a></td><td style="text-align:left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td></tr></tbody></table></div><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><div class="table-container"><table><thead><tr><th style="text-align:left">头文件</th><th style="text-align:left">函数和描述</th></tr></thead><tbody><tr><td style="text-align:left"><iostream></td><td style="text-align:left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td style="text-align:left"><iomanip></td><td style="text-align:left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td style="text-align:left"><fstream></td><td style="text-align:left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table></div><p><strong>延申待补充……</strong></p><h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><h1 id="C-高级"><a href="#C-高级" class="headerlink" title="C++高级"></a>C++高级</h1>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 菜鸡学习❀ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS1 Noetic</title>
      <link href="/2022/02/01/ros-1/"/>
      <url>/2022/02/01/ros-1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">如何移植别人的工程:</span><br><span class="line">在根目录 catkin_make 后 ,会报错,然后修改的地方在build里,需要更改Cmake.txt以及 Makefile ,再补上所需要的依赖,就可以了</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h1 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="常见操作指令"><a href="#常见操作指令" class="headerlink" title="常见操作指令"></a>常见操作指令</h1><p><strong>查找：</strong><br>rosc/roscd：切换当前工作目录到ros的某个程序包<br>rosls：按程序包的名称执行ls命令<br>catkin_ctreate_pkg：创建功能包<br>catkin_make：编译ROS工作空间，该src空间下所有程序包以及其子包都会被编译</p><p>-</p><p>roscore：启动管理器<br>rosrun：运行ROS程序包中的可执行文件<br>roslaunch：启动roscore，本地结点和远程结点，设置服务器参数（ssh）<br>roslaunch package_name filename.launch：启动包中的一个文件<br>rospack：获取程序包有关信息<br>rospack find：返回程序包的路径<br>rospack list：获取所有的程序包<br>rosdep：rosdep install package_name 可以下载安装ROS 程序包所需要的系统依赖项<br>roswtf：可以检查ROS系统并尝试发现问题<br>rostopic -h：查看所有Topic操作<br>rostopic list：获取所有的Topic列表<br>rosrun rqt_plot rqt_plot：图形化显示Topic<br>rostopic echo ‘topic namae’：查看某个Topic的信息</p><h1 id="video"><a href="#video" class="headerlink" title="video"></a>video</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg usb_cam std_msgs roscpp cv_bridge sensor_msgs image_transport</span><br><span class="line">    </span><br><span class="line">img_publisher.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_publisher&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Publisher pub = it.<span class="built_in">advertise</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  cv::VideoCapture cap;</span><br><span class="line">  cv::Mat frame;</span><br><span class="line">  <span class="keyword">int</span> deviceID=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">deviceID=argv[<span class="number">1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> apiID=cv::CAP_ANY;</span><br><span class="line">  cap.<span class="built_in">open</span>(deviceID+apiID);</span><br><span class="line">  <span class="keyword">if</span>(!cap.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">std::cerr&lt;&lt;<span class="string">&quot;ERROR! Unable to open camera&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">cap.<span class="built_in">read</span>(frame);</span><br><span class="line"><span class="keyword">if</span>(!frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, frame).<span class="built_in">toImageMsg</span>();</span><br><span class="line">pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_viewer.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">imageCallback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;view&quot;</span>, cv_bridge::<span class="built_in">toCvShare</span>(msg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (cv_bridge::Exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;</span>, msg-&gt;encoding.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_viewer&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  cv::<span class="built_in">startWindowThread</span>();</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Subscriber sub = it.<span class="built_in">subscribe</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">  $&#123;OpenCV_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">add_executable</span>(img_publisher src/img_publisher.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(img_viewer src/img_viewer.cpp)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_publisher $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_viewer $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;build_depend&gt;opencv2&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;opencv2&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;opencv2&lt;/exec_depend&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸡学习❀ </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习途中小Tips</title>
      <link href="/2022/01/10/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/01/10/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="About-Vim"><a href="#About-Vim" class="headerlink" title="About Vim"></a>About Vim</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">批量替换:</span><br><span class="line">:%s/abc/123/g </span><br><span class="line">-</span><br><span class="line">选中 单词开头或者结尾 (在v模式下) 按e进行选择</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><p><strong>重新连接Ubuntu联网指令：</strong></p><p><code>sudo /etc/init.d/network-manager restart</code></p><p><strong>重新挂载共享文件夹</strong></p><p><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code></p><p><strong>搜wifi:</strong></p><p><code>sudo iw dev wlan0 scan | grep SSID</code> </p><p><strong>交叉编译树莓派gcc：</strong></p><p><code>arm-linux-gnueabihf-gcc</code></p><p><strong>树莓派安全关机：</strong></p><p><code>sudo shutdown -h now</code></p><p><strong>树莓派重启：</strong></p><p><code>sudo reboot</code><br><strong>树莓派传输文件使用fillzeila：前面加上sftp://</strong></p><p><strong>树莓派拍照：</strong> <code>raspistill -o image.jpg</code><br>监控   :8080</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装软件：sudo  dpkg  -itar xvf xxx</span><br><span class="line">Linux查看pdf：zathura`</span><br><span class="line">LINUX解压文件：tar xvf xxx</span><br></pre></td></tr></table></figure><h3 id="摄像头推流："><a href="#摄像头推流：" class="headerlink" title="摄像头推流："></a>摄像头推流：</h3><p><code>/usr/local/bin/mjpg_streamer -i &quot;/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720&quot; -o &quot;/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot;</code></p><p><strong>人脸识别（虹软）临时路径：</strong></p><p><code>export LD_LIBRARY_PATH=/home/lz/face/samplecode/ASFTestDemo/linux_so/:$LD_LIBRARY_PATH</code> </p><p><strong>opencv:</strong><br>    编译时 加 <code>pkg-config --cflags --libs opencv</code></p><h3 id="百度文库下载"><a href="#百度文库下载" class="headerlink" title="百度文库下载:"></a>百度文库下载:</h3><p>网址baidu后面加三个v </p><p>继续补充…</p><p><strong>Typora+七牛云配置:</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 存储空间名</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 自定义域名</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span>:  <span class="string">&quot;&quot;</span>, <span class="comment">// 存储区域编号</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 网址后缀，比如？imgslim</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;img/&quot;</span> <span class="comment">// 自定义存储路径，比如 img/</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 小提示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客常用配置</title>
      <link href="/2022/01/01/hello-world/"/>
      <url>/2022/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Front-matter 是markdown 文件最上方以 —- 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于頁面配置<br>Post Front-matter 用于文章頁配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000604.png" alt=""></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:缩略图</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br><span class="line">another:::::::::::::::::::</span><br><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">author: </span><br><span class="line">img: /medias/banner/7.jpg</span><br><span class="line">coverImg: /medias/banner/7.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">toc: true</span><br><span class="line">password: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110</span><br><span class="line">mathjax: true</span><br><span class="line">summary: 自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- </span><br><span class="line">categories:</span><br><span class="line">- </span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000809.png" alt=""></p><h3 id="新-md"><a href="#新-md" class="headerlink" title="新.md"></a>新.md</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Copyright-beautify # 文章名称</span><br><span class="line">date: 2021-03-02 13:52:46 # 文章发布日期</span><br><span class="line">updated: 2021-03-02 13:52:46 # 文章更新日期</span><br><span class="line">copyright_author: Nesxc # 作者覆写</span><br><span class="line">copyright_url: #https://www.nesxc.com/post/hexocc.html # 原文链接覆写</span><br><span class="line">license: # 许可协议名称覆写</span><br><span class="line">license_url: # 许可协议链接覆写</span><br><span class="line">author: </span><br><span class="line">img: </span><br><span class="line">coverImg: </span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">toc: true</span><br><span class="line">mathjax: false</span><br><span class="line">password:</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">sticky: 1 #置顶用 越大置顶优先级越大</span><br><span class="line">aside: false&lt;-- 关闭侧边栏</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建日期</span><br><span class="line">updated: 更新日期</span><br><span class="line">cover: 文章封面</span><br><span class="line">description: 文章描述</span><br><span class="line">swiper_index: 1 #置顶轮播图顺序，需填非负整数，数字越大越靠前</span><br><span class="line">comments: false #关闭评论</span><br><span class="line">subtitle: 左上角显示</span><br><span class="line">description: 提示-&gt;左上角</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>给 js 脚本加上 <code>defer</code> 和 <code>ansyc</code> 属性来实现异步加载，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">https://unpkg.zhimg.com/vue@2.6.11&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/zjwo/CDN/js/pyq/pyq.min.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Boke相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
