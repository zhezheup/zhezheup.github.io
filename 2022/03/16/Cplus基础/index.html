<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>C++基础 | L哲哲のBlog</title><meta name="keywords" content="C++,菜鸡学习❀"><meta name="author" content="Leechee~"><meta name="copyright" content="Leechee~"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="加油!"><meta property="og:type" content="article"><meta property="og:title" content="C++基础"><meta property="og:url" content="https://www.lizheblogs.xyz/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="L哲哲のBlog"><meta property="og:description" content="加油!"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg"><meta property="article:published_time" content="2022-03-16T15:21:13.000Z"><meta property="article:modified_time" content="2022-04-04T10:33:52.386Z"><meta property="article:author" content="Leechee~"><meta property="article:tag" content="C++"><meta property="article:tag" content="菜鸡学习❀"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg"><link rel="shortcut icon" href="https://npm.elemecdn.com/lz-assets@0.0.3/image/sitepage.png"><link rel="canonical" href="https://www.lizheblogs.xyz/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:150},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:150,languages:{author:"作者: Leechee~",link:"链接: ",source:"来源: L哲哲のBlog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"mediumZoom",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++基础",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-04 18:33:52"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)});const t=saveToLocal.get("aside-status");void 0!==t&&("hide"===t?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/mycss.css"><script data-pjax defer src="https://unpkg.zhimg.com/echarts@4.7.0/dist/echarts.min.js"></script><script data-pjax defer src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/js/circleMagic.min.js"></script><link rel="stylesheet" href="/css/custom/twikoo_beautify.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/akilar-candyassets/js/SAO-Notify.js" async></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><script defer src="https://gcore.jsdelivr.net/gh/PipecraftNet/jsdelivr-auto-fallback@main/index.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lz-assets@0.0.3/css/runtime.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="SAO-scene"><div class="SAO-wrap"><div class="SAO-wall SAO-wall-right"></div><div class="SAO-wall SAO-wall-left"></div><div class="SAO-wall SAO-wall-top"></div><div class="SAO-wall SAO-wall-bottom"></div><div class="SAO-wall SAO-wall-back"></div></div><div class="SAO-wrap"><div class="SAO-wall SAO-wall-right"></div><div class="SAO-wall SAO-wall-left"></div><div class="SAO-wall SAO-wall-top"></div><div class="SAO-wall SAO-wall-bottom"></div><div class="SAO-wall SAO-wall-back"></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.lixingyong.com/2022/03/20/nyantocat.gif" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.lizheblogs.xyz/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye"></use></svg> <span>主页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-diannao"></use></svg> <span>我の网站</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shalou"></use></svg> <span>归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenzhang"></use></svg> <span>文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg> <span>相册</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qita"></use></svg> <span>其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youqinglianjie"></use></svg> <span>大佬</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoyan"></use></svg> <span>About 哲</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" onclick="btf.scrollToDest(0,500)" data-title="加油!">C++基础总结</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.lizheblogs.xyz/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye"></use></svg> <span>主页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-diannao"></use></svg> <span>我の网站</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shalou"></use></svg> <span>归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wenzhang"></use></svg> <span>文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce"></use></svg> <span>相册</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qita"></use></svg> <span>其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youqinglianjie"></use></svg> <span>大佬</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoyan"></use></svg> <span>About 哲</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-16T15:21:13.000Z" title="发表于 2022-03-16 23:21:13">2022-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-04T10:33:52.386Z" title="更新于 2022-04-04 18:33:52">2022-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/">技术帖</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="C++基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p><h1 id="基础More"><a href="#基础More" class="headerlink" title="基础More"></a>基础More</h1><p><code>size_t : typedef unsigned int</code></p><p>C++的静态转换: b为要转换的内容</p><p><code>int a=static_cast&lt;int 目标类型&gt;(b);</code></p><p>查看变量类型: <code>typeid(变量).name();</code></p><p>格式化输出流:</p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/8d5b7f9235bba470a9211975f9add9c31a30009c.jpg" alt=""></p><p>运算优先级:(优先级从上到下)</p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://i0.hdslb.com/bfs/album/4a20c75c88cde2b4aec77070eaf610af643576aa.jpg" alt=""></p><h3 id="枚举变量"><a href="#枚举变量" class="headerlink" title="枚举变量"></a>枚举变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">xx</span>:</span><span class="keyword">int</span> <span class="comment">//自动递增1,从上往下</span></span><br><span class="line">&#123;</span><br><span class="line">	normal,</span><br><span class="line">    high,</span><br><span class="line">    low=xx,</span><br><span class="line">    other, other1=other<span class="comment">//多个情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">xx use_xxn&#123;xx::normal&#125;;</span><br><span class="line">xx use_xxh&#123;xx::high&#125;;</span><br></pre></td></tr></table></figure><p>1.提高代码的可读性和安全性</p><p>2.枚举类型默认int型</p><p>3.枚举类型成员只能是整数类型</p><p>4.枚举类型和其他类型转换需要强制转换</p><h3 id="自定义变量名称"><a href="#自定义变量名称" class="headerlink" title="自定义变量名称"></a>自定义变量名称</h3><p>三种方式:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A Typename <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">typedef</span> Typename A; <span class="comment">//Typename被A替换</span></span><br><span class="line"><span class="keyword">using</span> A=Typename; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p><strong>自定义命名空间:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> yournamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ...</span><br><span class="line">    <span class="function">string</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>变量的声明周期:</strong></p><p>变量生命在代码块结束后死亡.</p><p>全局变量的生命程序运行一直存在</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::xx <span class="comment">//定义后使用双冒号使用</span></span><br></pre></td></tr></table></figure><p><strong>位运算:</strong></p><p>输出二进制文件.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">引用 bitset头文件</span><br><span class="line">std::bitset&lt;要显示的二进制位数&gt;(要显示的变量);</span><br></pre></td></tr></table></figure><p><code>std::boolalpha 可以将流的输出控制为bool类型</code></p><p><strong>字符处理</strong></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_111853.jpg" alt=""></p><p><strong>判断</strong></p><p>C++17语法</p><p>if(int a; check() ) {}</p><p>switch(变量声明 ；条件（）) {}</p><p><code>goto的使用 ： input&#123;代码段&#125; ... goto input；</code></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的地址连续</p><p>求大小</p><p><code>sizeof(a[])/sizeof(a[0])</code> or <code>sizeof(数组名/sizeof(类型名))</code></p><p><strong>基于数组的循环</strong></p><p><code>for(变量类型 变量名称 : 数组) &#123;&#125;</code></p><p><code>for(auto 变量名称 : 数组) &#123;&#125;</code></p><h2 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include<array></array></h1><p><code>std::array&lt; 变量类型 , 元素数量&gt; 变量名;</code></p><p><code>exp: std::array&lt;int ,5&gt;stuID; //五个学生的学号</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stuID.size();</span><br><span class="line">stuID.fill(x); //将所有元素都设置为x</span><br><span class="line">stuID.at(1); //返回stu[1]里的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p>array的优点基本都具备 size fill at</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include<vector></vector></h1><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_155716.jpg" alt=""></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_160124.jpg" alt=""></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>c++声明指针需要初始化</p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p><code>int* array[10] 数组里面存了10个指针</code></p><p><strong>指针详细 {待补充}</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="c内存分配"><a href="#c内存分配" class="headerlink" title="c内存分配"></a>c内存分配</h3><p><code>void* malloc</code> ： 用法{ }</p><p><code>nullptr 相当于0 （c++17新）</code></p><p><code>void* calloc(size_t count , size_t size);</code> : 为用户分配count*size字节个内存</p><p><code>void* realloc(void* _Block,size_t_size)</code> : 为用户重新分配内存，_Block是用户已经分配好的内存，Size是要求重新分配的大小</p><p><code>void* free(void* _Block)</code> : 释放内存</p><h3 id="c-内存分配"><a href="#c-内存分配" class="headerlink" title="c++内存分配"></a>c++内存分配</h3><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_002002.jpg" alt=""></p><p><strong>释放内存：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>  )  <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[x]) <span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><p><strong>风险</strong></p><ul><li><p>悬挂指针：释放了还在继续使用释放掉的地址</p></li><li><p>内存碎片：频繁申请和释放小块内存会造成内存碎片，原则上可以使用，实际上使得我们无法分配新的内存.但是new和delete的算法会帮助我们尽量规避</p></li></ul><p><strong>复制内存</strong></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220310012821.png" alt=""></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_013233.jpg" alt=""></p><h3 id="malloc和new本质区别"><a href="#malloc和new本质区别" class="headerlink" title="malloc和new本质区别"></a>malloc和new本质区别</h3><p>对于普通的数据类型来说malloc和new没什么区别,但是对于类来说,malloc仅仅是分配内存而new除了分配内存以外还会调用构造函数!</p><h3 id="free和delete本质区别"><a href="#free和delete本质区别" class="headerlink" title="free和delete本质区别"></a>free和delete本质区别</h3><p>对于普通的数据类型来说free和delete没有什么区别,但是对于类来说,free仅仅是释放内存空间,而delete不仅释放内存空间,还会调用类的析构函数</p><h3 id="delete和delete-本质区别"><a href="#delete和delete-本质区别" class="headerlink" title="delete和delete[]本质区别"></a>delete和delete[]本质区别</h3><p>对于普通的数据类型来说deletc和delete[]没有什么区别,但是对于类来说,delete仅仅是释放内存空间,且调用第一个元素的析构函数,而delete[]不仅释放内存空间,还会调用每一个元素的析构函数</p><p>对普通数据类型无所谓</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>引用的本质其实就是一种被阉割了的指针，虽然我们取址引用变量得到的是原地址的内存地址，但是引用变量也是占用内存的</code></p><p>引用需要初始化</p><p>提高代码效率，{个人觉得类似于软连接}</p><p>语法： <code>数据类型&amp;变量名称&#123;引用对象的名称&#125;；</code></p><p><code>exp： int a&#123;500&#125;; int&amp; la&#123;a&#125;;</code> la=500即a=5200.</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_015706.jpg" alt=""></p><p>第一种声明不允许用数组方式访问，第二种可以。</p><p>智能指针不允许指向别的智能指针。具有唯一性。</p><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset();</span><br><span class="line">//reset将会释放std::unique_ptr的内存空间，并且设置为nullptr</span><br><span class="line">get();</span><br><span class="line">//get返回std::unique_ptr的指针</span><br><span class="line">release();</span><br><span class="line">//release返回std::unique_ptr的指针,并且设置为nullptr，但是不会释放占用的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021212.jpg" alt=""></p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021553_edit_658178805450610.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr的复制</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrA&#123;&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrB&#123;std::make_shared&lt;int&gt;(5)&#125;;</span><br><span class="line">ptrA=ptrB;</span><br><span class="line">··························································</span><br><span class="line">//获得计数</span><br><span class="line">long std::shared_ptr.use_count();</span><br><span class="line">.use_count();会返回当前指针共有多少个对象调用</span><br><span class="line"></span><br><span class="line">bool std::shared_ptr.unique();</span><br><span class="line">//unique()会返回以一个bool值，if当前智能指针是唯一拥有该指针的人，返回true</span><br><span class="line"></span><br><span class="line">std::shared_ptr.reset();</span><br><span class="line">//将当前共享指针设置为nullptr，如果是最后一个拥有该指针的对象，释放内存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性</strong></p><p>可以有多个std::shared_ptr指向同一地址，同一地址下只有最后一个std::shared_ptr释放的时候，才会释放其所占用的空间，std::shared_ptr会记录当前有多少个智能指针调用</p><h2 id="C原生字符串"><a href="#C原生字符串" class="headerlink" title="C原生字符串"></a>C原生字符串</h2><p>字符串就是指针，数组</p><p>&lt;! 待补充 —&gt;</p><p><code>wchar_t str[0xff]&#123;L&quot;HEllo&quot;&#125;;</code> 宽字节常量</p><p>（使用utf-16实现UNICODE）</p><p><code>使用UNICODE标准 ： setlocale(LC_ALL,&quot;chs&quot;)</code> <code>使用wcout输出</code></p><p>std::cout 默认输出char类型的值时会当作字符串进行处理。</p><h2 id="联合体-union"><a href="#联合体-union" class="headerlink" title="联合体 union"></a>联合体 union</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">&#125;</span><br><span class="line">exp:</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> shp;</span><br><span class="line">    <span class="keyword">int</span>   xhp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过union可以创建一个联合体，union中的成员变量共享内存，因此 <strong>union的数据类型大小由其最大的成员变量决定</strong></p><p>union中任意一成员变量发生改变都可能影响别的变量</p><p><strong>匿名联合体、结构体</strong></p><p>顾名思义，没有名字的联合体和结构体</p><p>一般只用一次</p><h2 id="C-字符串string"><a href="#C-字符串string" class="headerlink" title="C++字符串string"></a>C++字符串string</h2><p><code>#include &lt;string&gt;</code></p><p>定义： <code>std::string str&#123;&quot;wow!&quot;&#125;;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; , 要截取的长度&#125;</code></p><p>exp：<code>string str&#123;&quot;1234&quot;,2&#125;; str=&quot;12&quot;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; ，起始位置 ， 要截取的长度&#125;</code></p><p><code>std::string 变量名称(要复制的个数，&#39;字符&#39;)</code></p><p><strong>连接字符串</strong> <code>std::string str(6,&#39;a&#39;); str=str+&quot;123; str=&quot;aaa123&quot;</code></p><p><strong>连接字符串和数字</strong> <code>std::string str = std::to_string(数字)；</code></p><p><strong>字符串连接字符串</strong></p><p>字符串不能直接和别的字符串连接，可以使用临时变量解决(std::string(xx));</p><p>可以 <code>&quot;变量&quot;&quot;变量&quot; 变成&quot;变量变量&quot;</code></p><p>也可以<code>str.append(&quot;你要拼接的内容&quot;)</code> 可以无限加</p><p><strong>字符串连接字符</strong> 直接+’字符’ 即可</p><p><strong>截取字符串</strong> <code>.substr(起始位置，要截取的长度); or .substr(起始位置)</code></p><p><strong>长度</strong> <code>std::string.length();</code> 得到长度</p><p><strong>字符串比较</strong> <code>.compare() 比如： str.compare(&quot;abcd&quot;);</code> 大于返回正数，相等等于0；</p><p>扩展： <code>.compare(起始位置,参与比较的长度,被比较的字符串);</code></p><p><strong>字符串搜索</strong></p><p><code>.find()</code> 用来搜素字符串的内容,并返回内容所在的位置,当返回值是<code>std::string::npos</code>表示未找到</p><p><code>.find(要搜索的内容 , 开始搜索的位置)</code></p><p><code>.find(要搜索的内容,开始搜素的位置,要纳入的字符串长度[注:是搜索内容的字符串])</code></p><p><code>.rfind()</code> 用法和<code>find</code>一样,从字符串尾部<strong>倒叙搜索</strong></p><p><strong>插入字符串</strong></p><p><code>.insert()</code> 可以在一个string字符串的指定位置插入另一个字符串</p><p><code>.insert(要插入的位置 , 要插入的字符串)</code></p><p><code>.insert(要插入的位置,要插入的字符个数,要插入的字符)</code> exp:id.insert(3,6,’x’);</p><p><code>.insert(要插入的位置,要插入的字符串,要插入的字符串的起始位置,要插入的大小)</code></p><p><code>.insert(要插入的位置,要插入的字符串,要插入的大小)</code></p><p><strong>替换字符串</strong></p><p><code>.replace</code> 可以替换string字符串中的内容</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;)</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,&#39;字符&#39;)</code>对单字符</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,替换后内容节选长度[此处是替换的字符串的])</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;,替换后的起始位置,替换后内容的节选长度</code></p><p><strong>删除字符串</strong></p><p><code>`.erase()</code> 删除字符串中的内容</p><p><code>.erase(要删除的起始位置,要删除的起始长度)</code></p><p><code>.erase(要删除的起始位置)</code> exp: 从起始位置删除所有的内容</p><p><code>str.clear();</code></p><h3 id="指针数组字符串内存学习"><a href="#指针数组字符串内存学习" class="headerlink" title="指针数组字符串内存学习"></a>指针数组字符串内存学习</h3><p>{待补充}</p><p><strong>想得到放字符串这段内存的区域</strong></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220311_164550.jpg" alt=""></p><p>不能修改!</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>exp：输入中文英文等字符串，正确返回字符个数</p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012145.jpg" alt=""></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012436.jpg" alt=""></p><p>待补充</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>指针参数</strong></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_025458.jpg" alt=""></p><p><strong>数组参数</strong></p><p>建议用数组方式引用</p><p><strong>引用参数</strong></p><p>指针可以传入nullptr，而引用不可以</p><p><strong>默认实参</strong></p><p>exp： <code>void func(int a,int&amp; b,int* c,bool x=true)</code></p><p>此时用户根据需要调用func时x可写可不写，不写默认是true</p><p>！<strong>默认实参只能放在最后</strong> 引用定义的时候不能瞎指</p><p><strong>不定量参数</strong></p><p><code>mian（int argc,char** argc）&#123;&#125;</code> C语言也常用</p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_224012_edit_807927517925156.jpg" alt=""></p><p><strong>函数返回：返回指针和引用</strong></p><p>{知识很多 待补充}</p><p>比如返回结构体 ，返回指针，返回引用，传递引用参数时的类型转换</p><p>数组的引用：</p><p>exp： <code>int a[100] int(&amp;b)[100]=a</code></p><p>传递数组引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> (&amp;array)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数：右值引用"><a href="#函数参数：右值引用" class="headerlink" title="函数参数：右值引用"></a>函数参数：右值引用</h2><p>ps：函数使用引用会节约内存消耗</p><p>左值就是一般左边定义的东西有明确的内存空间 可以读取写入，右值是存放在临时空间内</p><p>exp：<code>*(a+1)=2</code> 此事a+1仍然是一个右值</p><p><code>int&amp;&amp;</code> 右值引用 exp:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; e = <span class="number">100</span>+<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123; std::cout&lt;&lt;a; &#125;</span><br><span class="line"><span class="built_in">Add</span>(e+<span class="number">320</span>+<span class="number">329</span>);</span><br></pre></td></tr></table></figure><p>设计字符串类的时候会感受到…….</p><p>exp: 创建一个临时的角色信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">int</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role <span class="title">createmonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(Role&amp;&amp; rl)</span><span class="comment">//没有分配内存空间却达到了同样的效果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;rl.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220313_022431_edit_817161374477392.jpg" alt=""></p><h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><p>loading</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>可以指向特定类型函数的指针</p><p>函数返回类型 (*函数指针变量名)(参数类型 参数名称, ……参数类型 参数名称);</p><p><strong>转类型</strong> <code>char (*myadd)(int,int)=(char (*)(int,int)Add);</code></p><p>强转太长了怎么办:</p><p><code>typedef函数返回类型 (*函数指针变量名)(参数类型 参数名称,....参数类型 参数名称);</code></p><p>也可以: <code>using pfadd=char (*)(int,int);</code></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>C++有，c语言需要自己实现，不自带此功能</p><p>尽管函数名称相同,但是在我们调用函数时,通过函数参数的不同,编译器还是能够确定我们调用的是哪一个函数,因此程序能够准确的编译</p><p>！ 是参数的不同可以确定是哪个函数。</p><p>但是编译器无法单纯通过返回值来确定你要返回的函数,参数要不同!</p><p>exp: <code>float ave() 和 int ave()</code> 无法重载</p><p>exp: 同样的函数,用指针和数组写法不能重载,引用也不行</p><p>Tips:为什么俩个函数,有一个int&amp; 一个float ,我定义了char变量去调用,强转为(int)x型,去调用函数却仍然是float函数,因为<strong>强转只是声明了一个临时的变量,而引用需要已经定义的(真实存在的)变量</strong></p><p>同样的函数,一个int 一个const int也不行(会出现歧义)</p><p>但是一个是int的引用int&amp; 一个是 const int&amp; 常量引用,那就可以重载</p><p>函数重载的时候不可以设置默认参数</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>除了类型不同外,函数的运算逻辑都一样,这样的函数我们就可以利用函数模板技术来生成对应的函数.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span><span class="comment">//ave求平均值的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于int ave(int a,int b)</span></span><br><span class="line"><span class="keyword">char</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于char ave(cahr a,char b)</span></span><br><span class="line">exp:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b,type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type1 a;<span class="comment">//可以定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以指定一个函数模板</span></span><br><span class="line">exp： ave&lt;<span class="keyword">int</span>&gt;(<span class="number">192.0f</span>,<span class="number">159.3f</span>); <span class="comment">// 执行int ave</span></span><br></pre></td></tr></table></figure><h3 id="函数模板和重载"><a href="#函数模板和重载" class="headerlink" title="函数模板和重载"></a>函数模板和重载</h3><p>函数模板的例外处理</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">float</span> <span class="title">ave</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b<span class="number">-100.0f</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">我们可以利用<span class="keyword">template</span>&lt;&gt;定义一种函数模板的例外情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数重载优先于函数模板,但是函数模板的例外情况要优先于函数重载</strong></p><p>函数模板的重载 函数模板的重载也是通过参数来区分</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="推断函数模板返回类型-多不同类型"><a href="#推断函数模板返回类型-多不同类型" class="headerlink" title="推断函数模板返回类型(多不同类型)"></a>推断函数模板返回类型(多不同类型)</h3><p>返回值,传入参数都不同</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时调用的时候可以 ave&lt;int,int&gt;();类似于这样强行更改类型</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">2</span>;</span><br><span class="line">M</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">bigger&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line">bigger&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//### 如何更加智能的推断-&gt; (c++14后)</span></span><br><span class="line">temp1ate &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以利用auto来推断返回值的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ab?a:b;)</span><br><span class="line">&#125;</span><br><span class="line">注*<span class="keyword">auto</span>做返回类型推断是在C++<span class="number">14</span>之后引入的</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b-&gt;<span class="keyword">decltype</span>(a&gt;b?a:b)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) bigger(type1 a,type2 b) <span class="comment">//decltype(auto)可以通过引用更改值</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//decltype(auto)为C++14后的写法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><h3 id="函数模板参数"><a href="#函数模板参数" class="headerlink" title="函数模板参数"></a>函数模板参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充 很多</span><br></pre></td></tr></table></figure><h3 id="函数模板本质"><a href="#函数模板本质" class="headerlink" title="函数模板本质"></a>函数模板本质</h3><p>待补充</p><h2 id="auto-and-decltype"><a href="#auto-and-decltype" class="headerlink" title="auto and decltype"></a>auto and decltype</h2><p>c++11之后出现</p><p>auto可以声明一个变量,让编译器根据变量的值来推断变量的类型</p><p>例如<br><code>auto a&#123;123&#125;;</code> 相当于<code>`int a&#123;123;</code> `<br>利用auto的这一特性我们可以利用auto来创建一个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ave</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">注*以上都并非<span class="keyword">auto</span>的最恰当用法,不管是函数还是变量,都不推荐使用<span class="keyword">auto</span>来声明</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>不能保留<span class="keyword">const</span>属性</span><br><span class="line">比如</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line">c是<span class="keyword">int</span>类型而非<span class="keyword">const</span>类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> 会优先推断为值类型而非引用类型</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; la=a;</span><br><span class="line"><span class="keyword">auto</span> d=a;</span><br><span class="line">d为<span class="keyword">int</span>类型而非<span class="keyword">int</span>&amp;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span>利用函数返回值来确定类型的时候,函数会执行</span><br><span class="line"><span class="keyword">auto</span> x=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//ave(1,2)会执行x的类型依据ave函数的返回类型来确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>会优先把值匹配成值类型而非引用类型,就以本例来说</span><br><span class="line">假设我们希望bigger函数返回的是<span class="keyword">int</span>&amp; 用<span class="keyword">auto</span>声明达不到这样的效果,为了达到这种目的,我们可以使用另外一种技术:  拖尾函数</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span>-&gt;<span class="keyword">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype关键字可以得出一个表达式的类型;</p><p>语法:decltype(表达式)<br><code>int a&#123;&#125;;</code><br><code>unsigned b;</code><br><code>decltype(a-b) x;相当于unsigned x;</code></p><p>如果decltype内的表达式没经历任何运算,那么得出的数据类型同表达式内的数据类型,并且<strong>decltype可以保留const和引用类型</strong> .</p><p>编译器依处理decltype关键字时的原则:</p><p>如果decltype内的表达式经历了运算,那么得出的数据类型是根据运算结果是否有固定的内存地址(左值)来决定的,如果有固定的内存地址则得出的类型为该类型的引用类型,如果没有固定的内存地址,则得出的类型为该结果的类型.</p><p>如果decltype内的表达式是一个函数,那么得出的数据类型是根据函数的返回类型来确定的;(decltype不会执行函数)</p><h2 id="static-only变量-and-inline"><a href="#static-only变量-and-inline" class="headerlink" title="static(only变量) and inline"></a>static(only变量) and inline</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>利用static可以声明一个静态变量 static类型变量名称;<br>例如:<br>static int a;<br>static的变量,如果没有指定初始化的值,那么会初始化为0,无论有没有指定初始值,都只会初始化一次!</p><p>exp: count不会只会在函数被初始化一次,生命周期很长,值会保留</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline int Add(int a,int b){<br>return a+b;<br>}<br>我们可以用inline声明一个内联函数<br>内联函数将会建议编译器把这个函数处理成内联代码以提升性能<br>始终是建议,具体编译器是否采纳,由编译器决定</p><p>[有些过时了]</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h2 id="函数一些理论"><a href="#函数一些理论" class="headerlink" title="函数一些理论"></a>函数一些理论</h2><h3 id="理解定义和声明"><a href="#理解定义和声明" class="headerlink" title="理解定义和声明"></a>理解定义和声明</h3><p>我们写的函数就是函数的定义</p><p>因为函数的定义是我们要告诉计算机具体如何来执行我们的命令,所以这个命令必须是明确的,你不能告诉它同时往东并且往右,这就说明我们编写代码的时候,你不能多次定义一个函数!<br>因此函数的定义只能有一次!<br>但是函数的声明是我们和编译器的对话,在某些特殊的场景下,我们可以多次声明一个函数!<br>虽然编译器觉得我们啰嗦,但是并不影响我们之前的感情。</p><p>声明的本质是与编译器的对话,单纯的声明并不存在内存的分配,只是给编译器一个大体的概念，既然是对话,我们可以多次对话,所以对于同一个事物,我们可以多次声明;<br>而定义的本质是要通过编译器与计算机对话,这就涉及到内存的分配和访问,因此同一事物,不管声明多少次,但是只能有一次定义;<br>变量其实也适用这个规则,我们可以通过关键字extern声明一个变量,而把变量的声明和定义分开;<br>我们写函数的声明的时候,没有写extern关键字,是因为函数的声明本身就是extern的,因此不需要我们手动指出;<br>extern 的作用也是告诉编译器,此处只是一个声明,你去别处找定义,因此extern是针对的全局变量，因为局部变量不存在去别U找的可能性!而函数的声明自带extern属性,因此函数本身也是全局的!<br>例如: <code>extern int a;</code></p><p>函数名是内存地址</p><h3 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h3><p>多个源码共用一个全局变量<br>在头文件中声明多个源文件中要共用的全局变量<br>察<br>比如<br><code>extern int verId;</code><br>至于verld的定义你可以放到任何源文件中,但是不可以放到头文件中,因为这样就违背了乎个事物只能定义一次的原则!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">放在头文件中的第一行,可以防止头文件被多次调用</span><br><span class="line"></span><br><span class="line">#ifndef</span><br><span class="line">#define</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="创建自己的SDK"><a href="#创建自己的SDK" class="headerlink" title="创建自己的SDK"></a>创建自己的SDK</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION <span class="meta-string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">namespace</span> my_sdk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Getversion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤:(vs环境) 做成静态库</p><p>右键属性-&gt;配置类型.静态库 .lib-&gt;右键属性 . 生成-&gt;打开文件夹 库做好了 .lib</p><p>使用时:<br>右键属性-&gt;包含目录 放入自己的lib-&gt;库目录 加入自己的.h目录-&gt;</p><p>几种方法: 1: <code>#pragma comment(lib,&quot;xxx.lib&quot;)</code></p><p>2: 右键属性-&gt;链接器-&gt;输入-&gt;附加依赖项(库目录需要有)</p><h3 id="创建项目类型"><a href="#创建项目类型" class="headerlink" title="创建项目类型"></a>创建项目类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 函数调用约定</span><br><span class="line"></span><br><span class="line">函数调用约定是函数调用与被调用者之间的一种协议,这个协议主要规定了以下两个内容:</span><br><span class="line"></span><br><span class="line">`如何传递参数` `如何恢复栈平衡`</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">函数调用约定_cdecl:</span><br><span class="line">__cdecl参数入栈顺序从右到左</span><br><span class="line">堆栈平衡:谁调用谁平衡</span><br><span class="line">正因为__cdecl这种堆栈平衡方式,能够支持不定量参数</span><br><span class="line"></span><br><span class="line">函数调用约定_stdcall</span><br><span class="line">___stdcall参数入栈顺序从右到左次</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">Windows编程中WINAPICA1LBACK都是__stdcall的宏</span><br><span class="line">生成的函数名会加下划线,后面跟@和参数尺寸</span><br><span class="line">int _stdcallave(int a, int b)</span><br><span class="line"></span><br><span class="line">函数调用约定__fastcall</span><br><span class="line">第一个参数通过ecs传递第二个参数通过edx传递</span><br><span class="line">剩余参数入栈顺序从右到左</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">fastcall的函数执行速度比较快</span><br><span class="line"></span><br><span class="line">_thiscall 用作C++中类的访问,我们将在类的底层时讲这种callnaked call是一个不常用的调用约定,一般用于实模式驱动开发</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>套娃&gt;&gt;&gt;</p><p>a调用b,b调用a称为互递归函数</p><p>递归会造成栈溢出</p><p>内联函数不能递归</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="转换单元"><a href="#转换单元" class="headerlink" title="转换单元"></a>转换单元</h3><p>我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include<xxx.h>)合并后,称为一个转换单元;<br>编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象);<br>最后<strong>链接器将各个转换单元的对象文件链接起来,生成我们的目标程序;</strong><br>比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误.</xxx.h></p><h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><p>即我们在编写代码中,C++标准未作规定的行为,称为未定义行为,未定义行为的结果是不确定的,具体在不同的编译器下会有不向的效果; 比如<br><code>c=2*a++ + ++a*6;</code><br>这里先算a++还是先算++a就是一个未定义行为<br>比如:<br><code>int x=-25602;×=x&gt;2;</code><br>x的结果在不同的编译器下是不确定的,因为这也属于未定义行为</p><h3 id="One-Definition-Rule"><a href="#One-Definition-Rule" class="headerlink" title="One Definition Rule"></a>One Definition Rule</h3><p><strong>单一性规则</strong></p><p>ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则;<br>但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C++20)在每个转换单元中都只允许有一个定义;非inline的函数或变量(C++17),在整个程序中,有且仅有一个定义;</p><p>总结: 有多个声明 , 只能有一个定义</p><h3 id="名称的链接属性"><a href="#名称的链接属性" class="headerlink" title="名称的链接属性"></a>名称的链接属性</h3><p>程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的;<br>链接属性分为以下三种:<br>内部链接属性:该名称仅仅在本转换单元中有效<br>外部链接属性:该名称在其他的转换单元中也有效<br>无链接属性:该名称仅仅能够用于该名称的作用域内访问</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A B</span></span><br><span class="line">将标识符A定义为B的别名</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>整数int</span></span><br><span class="line">整数a&#123;&#125;;</span><br><span class="line"></span><br><span class="line">取消定义： <span class="meta">#<span class="meta-keyword">undef</span></span></span><br><span class="line">    </span><br><span class="line">定义复杂表达式的宏：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(X,Y)  X+Y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVE(X,Y)  (X+Y)/2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIGGER(X,Y)  ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">AVE</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">BIGGER</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">#可以将一个标识符参数字符串化</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(X) std:cout&lt;&lt;#X <span class="comment">//字符串</span></span></span><br><span class="line"><span class="built_in">SHOW</span>(<span class="number">1234f</span>g);=&gt;std:cout&lt;&lt;<span class="string">&quot;12345fg&quot;</span></span><br><span class="line">##可以连接两个标识符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1(X,Y) void X##Y()&#123;std:cout&lt;&lt;#Y;&#125; <span class="comment">//连接字符串</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用#define 的方式定义常量并不安全.</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>有时候为了方便管理,把相关的函数,变量,结构体等会附加到一个命名空间中<br><code>namespace t &#123;int value;&#125;</code><br>访问这个命名空间的变量<br><code>t:value</code></p><p>所有具有链接属性的对象,只要没有定义命名空间,就默认定义在<code>全局命名空间</code>中,全局命名空间中成员的访问不用显示的指定,当局部名称覆盖了全局名称时才需要显式的指定全局命名空间;<br><code>int a; ::a=250</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局命名空间的扩展</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> weight &#123;<span class="number">1980</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> height&#123;<span class="number">1080</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">第二个htd属于对htd命名空间的扩展,weight和height同属一个命名空间</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间拓展</span></span><br><span class="line"><span class="function"><span class="keyword">namespace</span> htd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> htd:<span class="built_in">sendSms</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">namespace</span> hack</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> htd::hack::<span class="built_in">hackServer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">htd::sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未命名空间</span></span><br><span class="line">不给命名空间指定名称,将会声明一个未命名的命名空间</span><br><span class="line"><span class="keyword">namespace</span> &#123;&#125;</span><br><span class="line">未命名的命名空间中声明的内容一律为内部链接属性,包括用<span class="keyword">extern</span>声明的内容,未命名的命名空间仅仅在本转换单元中有效</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的别名</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">namespace</span> hack&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer=htd::hack;</span><br><span class="line">hSever:<span class="built_in">hackServer</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预处理逻辑指令"><a href="#预处理逻辑指令" class="headerlink" title="预处理逻辑指令"></a>预处理逻辑指令</h2><p><code>#ifndef #if #elif</code></p><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//标准预定义宏</span><br><span class="line">__func__</span><br><span class="line">编译器支持ISO C99和ISO C++11指定的预定义标识符</span><br><span class="line">函数的名称</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025308.jpg" alt=""></p><p>//下面是微软公司做的宏</p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025523.jpg" alt=""></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>为了方便调试,在编码风格上:</p><p>1 模块化<br>2 使用能够体现出具体意义的函数名和变量名</p><p>3 使用正确的缩进和代码块<br>4 良好的注释习惯</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充。。。</span><br></pre></td></tr></table></figure><h2 id="assert调试-（断言）"><a href="#assert调试-（断言）" class="headerlink" title="assert调试 （断言）"></a>assert调试 （断言）</h2><p>语法:<br>assert(bool表达式);<br>如果括号内的bool表达式为false<br>则会调用std:abort()函数<br>弹出对话框<br>assert宏需要头文件 cassert</p><p>可以通过 <code>#define NDEBUG</code> 关闭 要放在include前</p><p>static_assert用于编译时检查条件<br>static_assert(bool表达式,”错误信息”);<br>C++17新语法：<br>static_assert(bool表达式);<br>与assert不同,static_assert主要是用来在编译时检查重要的条件</p><p>因此检查的bool表达式中,只能用于常量</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164728551916780271586411%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164728551916780271586411&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81913729.142^v2^pc_search_insert_es_download,143^v4^control&amp;utm_term=stl&amp;spm=1018.2226.3001.4187">STL介绍</a></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>00P(Object Oriented Programming)即面向对象编程,本质上是一种编程思想,通过把我们编程中遇到的事物来抽象成对象来编程;与OOP相关的还有OOD(面向对象设计),00A(面向对分析)等;<br>OOP应当遵循OOD的原则,所有坏的OOP代码基本都是违反了OOD原则</p><p>SOLID原则 { 待百度 }</p><h3 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h3><p>封装：</p><p>继承：</p><p>多态：</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//影响后面出现的内容 只能类中使用</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> hpRecover;-&gt;&gt;成员变量</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> -&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	hpRecover=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> hp;-&gt;&gt;成员变量</span><br><span class="line">	<span class="keyword">int</span> damage; -&gt;&gt;成员变量</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span>-&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	role.hp-=damage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;<span class="comment">//外部定义后需要定义成这样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROLE::Act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>空class默认一个内存空间</p><p>inline成员函数： （推荐写在头文件里）</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数的指针 ， 代表定义的成员本身</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"><span class="keyword">int</span> hp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Role::GetHP</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const对象只能调用const成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const对象不能以任何方式改变,这是const的原则,在这个基本原则下,产生了一些列效应,比如const对象只能调用const成员函数; const对象无法调用别的成员<br>另外一个我们不注意的变化是,在const成员函数下,this指针也变成了const指针</p><p><strong>const类型转换</strong></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_174156.jpg" alt=""></p><p><strong>mutable</strong></p><p>mutable声明的成员变量可以被const成员函数修改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> hp;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> getHPCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> GetHP0 <span class="keyword">const</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">int</span> Role:GetHP0 <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">getHPCont++;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在类的定义中有一种特殊的成员函数叫做构造函数.构造函数在类被创建时自动被调用,一般用来创建新的类实例时执行初始化操作构造函数与它所在的类同名,并且没有返回值,任何类都至少有一个构造函数;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROLE</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> hpRecover;</span><br><span class="line">	<span class="keyword">void</span> lnit0</span><br><span class="line">	&#123;</span><br><span class="line">		hpRecover=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ROLE</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> hp;</span><br><span class="line">	<span class="keyword">int</span> damage;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>&#123;</span><br><span class="line">		role.hp-=damage;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//跟java一样 ， 构造函数和类同名</span></span><br><span class="line">如果什么都不做 推荐<span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>被explicit关键字修饰的构造函数会禁用类型转换</p><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ROLE</span>(<span class="keyword">int</span> _lv,<span class="keyword">int</span> _damage):lv&#123;_lv&#125;, damage&#123;_damage&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>初始化时，初始化可以这样写快速初始化</p><p>效率更高，有时候只能这样去初始化</p><p><strong>使用成员初始化列表这样的方式构造类,要注意一个问题,即为成员赋值的顺序不是依据代码的顺序,而是成员变量在类的出现顺序;</strong></p><p><strong>委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</strong></p><p><code>ROLE(int _lv,int xx):ROLE(_lv)</code> 这种是委托构造，关于lv的都在ROLE这个构造函数里</p><p>副本构造函数</p><p>编译器为类指定了一个默认的副本构造函数,我们也可以手动指定副本构造函数</p><p><code>Role role1; Role role2(role1);</code></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在类中还有一种特殊的成员函数,叫做析构函数,析构函数在类的生命周结束时,被自动调用,一般用来做 扫尾工作 比如释放内存,关闭句柄等等,如果一个类没有定义析构函数,那么编译器会自动添加一个空的析构函数,析构函数只能有一个;<br>析构函数没有参数,没有返回类型,一般不会手动调用,如果类的析构函数为空,最好使用关键字default来定义,例如:<br><code>~ROLE()=default;</code></p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>我们可以在类中通过static关键字声明一个类的静态成员变量,类的静态成员变量的特点:<br>1 所有类的实例中,共享类中的静态成员变量</p><p>2 类的静态成员变量在没有类的实例的情况下,依然可以访问</p><p>3 类的静态成员变量并不完全属于类 内存空间不属于类</p><p>实例类不管多少个，static都不变，被所有实例共享一个内存空间</p><p>c++17后 可以 <code>inline static int count&#123;20&#125;</code> 来定义</p><p><code>const static int count&#123;20&#125;</code></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>我们可以利用static关键字声明一个类的静态成员函数,类的静态成员函数有如下特点:</p><p>(1)不管有没有创建类的实例,都可以访问类的静态成员函数<br>(2类的静态成员函数不能访问非静态的成员变量<br>(3)类的静态成员函数不能是const<br>(4)类的静态成员函数不能使用this指针</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">可以通过<span class="keyword">friend</span>关键字声明一个函数为某个类的友元函数,友元函数可以访问该类中的所有成员</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hp;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetHP</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t.<span class="built_in">ResetHP</span>();</span><br><span class="line">	t.hp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>俩个类交朋友的话 在另一个类上面声明 <code>class 类名</code> 即可</p><p>友元 不建议用</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>把一个类写在一个类里</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line">	<span class="keyword">int</span> mp;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> lv;</span><br><span class="line">	&#125;;</span><br><span class="line">我们可以在类的声明中再声明一个类,在类中声明的类称为嵌套类,而声明嵌套类的类称为外层类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>作用域</strong></p><p>嵌套类的声明在外层类中,因此嵌套类的作用域受外层类限定</p><p>假如要在类外声明女个Weapon对象<br><code>Role::Weapon mWpon;</code><br>嵌套类的作用域受封装属性管辖,即private封装的嵌套类是无法在类外使用的</p><p><strong>在类外定义嵌套类</strong></p><p><code>class ROLE::Weapen</code> 在外的类要这么写 。 函数、对象同理</p><p>函数指针情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span>;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span>:</span>:Weapon&#123;</span><br><span class="line"><span class="function">Weapon*<span class="title">CreateWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">CreateWeapon</span>()&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嵌套类可以访问外层类的所有成员<br>外层类仅能访问嵌套类的公有成员</p><p><strong>局部类</strong></p><p>定义在函数内的类称为局部类</p><p>局部类的定义必须写在类内</p><p>局部类中不允许使用静态成员变量</p><p>局部类可以访问全局变量</p><p><strong>嵌套类模块化问题</strong></p><p>多文件时。嵌套头文件，类出错 注意头文件</p><h2 id="类的成员函数的函数指针"><a href="#类的成员函数的函数指针" class="headerlink" title="类的成员函数的函数指针"></a>类的成员函数的函数指针</h2><h2 id="从底层理解类（逆向）"><a href="#从底层理解类（逆向）" class="headerlink" title="从底层理解类（逆向）"></a>从底层理解类（逆向）</h2><p>{待补充}</p><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>在OOP编程中,万物皆对象,我们如何让这些对象也能够像普通类型一样实现加减乘除呢?比如我们学习过的std:string对象<br><code>std:string str=&quot;大家好!&quot;;</code><br><code>str=str+”才是真的好!&quot;;</code><br>要实现这个功能我们就要对运算符+重新进行设计,当我们的对象进行+运算时不再是编译器默认的+预算,而是进入我们指定的函数,这种重新设计运算符规则的技术就称为运算符重载!<br>语法:<code>返回类型operator运算符0</code><br>//例如 <code>bool operator&lt;(const Role&amp; role);</code></p><p>非类成员函数实现需要使用友元定义</p><p>即： <code>man&lt;woman == man.operator&lt;(woman) == man&lt;woman</code></p><h3 id="原则和时机"><a href="#原则和时机" class="headerlink" title="原则和时机"></a>原则和时机</h3><p><strong>意义</strong></p><p>(1）让类也支持原生的运算比如＋-*/<br>(2）提升对程序的控制权比如重载new delete newdelete[<br>备注:<br>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率</p><p><strong>限制</strong></p><p>(1)不能自创运算符比如=== ,=&lt;&gt;=只能重载现有运算符</p><p>(2)以下运算符不能重载<br>(a)对象访问运算符．例如 user.hp</p><p>(b)作用域解析运算符::例如std::cout</p><p>(c)求大小的运算符sizeof 例如sizeof(int)</p><p>(d)条件运算符?:例如b=a&gt;c?100:200<br>(3)不能修改运算符本身的优先级,相关性<br>(4)在C++17后，也不能修改运算符的操作数的计算顺序，在C++17前，编译器可以自由选择如何计算（未定义行为)</p><p>(5)除了delete/delete和new/new外,不能对原生数据类型的其他运算符进行重载，比如把char类型的+定义为-</p><p>(6)除了new和delete以为，其他运算符的arity(运算符关联的操作数的个数或者是关联的参数）一律不能修改</p><p><strong>原则</strong></p><p>(1)不要改变运算符本身的意义,比如把加法重载为减法<br>(2)不建议重载逻辑运算符&amp;&amp; ||,取址运算符&amp; 逗号运算符，<br>备注:重载后的逻辑运算符将不会进行短路测试，在C++17标准前，编译器可以自由决定先计算左操作数还是右操作数,在C++17后计算的顺序规定为先计算左再计算右</p><p><strong>语法</strong><br>二元运算符的重载<br>利用全局函数<br><code>返回类型 operator 运算符(类型 左操作数,类型 右操作数）</code><br>利用类的成员函数<br><code>返回类型 operator 运算符(类型 右操作数)</code><br>一元运算符的重载<br>利用全局函数返回<br><code>返回类型 operator 运算符(类型 操作数)</code><br>利用类的成员函数<br><code>返回类型 operator 运算符()</code></p><p>有的运算符只能重载为类的成员函数,有些运算符只能重载为全局函数,有些运算符既可以重载为类的成员函数又可以重载为全局函数,如果一个运算符既可以重载为成员函数又可以重载为全局函数,我们一般推荐重载为类的成员函数,因为类的成员函数可以是虚函数,单全局函数不能是虚函数,如果这个运算符不修改对象,应该将这个成员函数限定为const<br>运算符重载的参数一般可以传递值或者引用,大部分情况下,能够传递引用就不要传递值,对于不会修改的值最好是限定为const,某些时候要擅用使用右值引用&amp;&amp;作为参数<br>运算符重载的返回值一般来说可以是任何类型,但是尽量要符合运算符的原意,比如把&gt;运算符返回指针类型,把+返回bool类型,都不是很好的选择</p><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>{待补充}</p><p>很多符号</p><h2 id="重载类型转换"><a href="#重载类型转换" class="headerlink" title="重载类型转换"></a>重载类型转换</h2><p>1 类型转换运算符只能重载为类的成员函数</p><p>2 类型转换运算符没有返回值。它的返回值由类型转换的类型来决定</p><p>3 语法 ``</p><p>4 <code>operator 类型() const</code></p><p>{待补充}</p><p><code>什么是隐试类型转换： float x=2 此时2是int型 这是就是隐式类型转换转成float型</code></p><h2 id="重载内存分配"><a href="#重载内存分配" class="headerlink" title="重载内存分配"></a>重载内存分配</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>假设有一个类animal现在我们基于animal类创造一个新类monkey,那么我们说类animal</p><p>monkey类的基类(父类),moneky类是anima类的派生类(子类),子类自动继承包含了父类的成员变量以及成员函数!</p><p>子类不能继承父类的构造函数,析构函数,重载赋值运算符,虽然不能继承,但是这些内容依然是存在于父类中的。</p><p>如果我们继续基于monkey创造一个新类bigMonkey,那么monkey是bigMonkey的直接基类,animal是bigMonkey的间接基类</p><p><code>class 类名:访问属性[public|private|protected] 父类名称</code></p><p>protected: 只有子类和友元可以访问</p><p>不想被别人继承的话 后面加 <code>final</code></p><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220316202707.png" alt=""></p><p><strong>修改继承成员的访问属性</strong></p><p>可以用<code>using 基类名::成员名</code> 来修改继承来的成员的访问属性</p><p><strong>使用proteted和private访问属性有几个好处</strong></p><p>可以更好的封装父类成员</p><p>可以在子类作为基础进行派生类的时候提供继承控制</p><p>将保护属性为private的父类产生的子类作为基类的时候,派生类继承但不能访问构建其父类的基类成员</p><p>将保护属性为protected的父类产生的子类作为基类的时候,派生类继承且可以访问其非私有成员</p><p><strong>继承访问属性的选择</strong></p><p>一般来说,尽量射击类的成员变量为private,如果需要访问这些成员变量,应该提供setter以及getter函数</p><h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p><strong>派生类</strong></p><p>构造顺序:先构造基类再构造派生类 (父亲-&gt;儿子)</p><p><strong>父本构造函数</strong></p><p>一个由另一个来复制. 执行时就不会调用原本的构造函数了</p><p>exp: <code>actObject(const actObject&amp; obj)</code></p><p><strong>继承构造函数</strong></p><p>通过 <code>using 基类::基类构造函数</code> 可以继承基类构造函数,但是默认构造函数与副本构造函数不会被继承</p><h2 id="继承析构函数"><a href="#继承析构函数" class="headerlink" title="继承析构函数"></a>继承析构函数</h2><p>先释放派生类,再释放基类 , 与构造顺序相反</p><p>当基类和派生类的成员函数同名时,要分俩种情况:</p><p>1 函数名相同,参数不同 <code>using 基类::函数名</code></p><p>2 函数名相同,参数相同 <code>基类::函数名</code></p><p>exp: <code>obj.lastObject::lastlastObject::show();</code></p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>一个类可以拥有多个父类,并且可以继承各个父类的成员 (不推荐用)</p><p><code>class xx: public x1 , public x2 &#123;&#125;;</code></p><p><strong>多重继承带来的重复继承问题</strong></p><p>问题时继承来的东西重复继承</p><p>首先可以强制指定解决√</p><p>另一方法: <strong>虚基类</strong> <code>class xx:public virtual x&#123;&#125;;</code></p><p>意思时只引入一次,第二次不引入</p><h2 id="内存角度理解"><a href="#内存角度理解" class="headerlink" title="内存角度理解"></a>内存角度理解</h2><p>{深入理解 待补充}</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="对象多态"><a href="#对象多态" class="headerlink" title="对象多态"></a>对象多态</h2><p>exp: 人是动物√ 动物是人×</p><p>即第一个第向上转型(父类=&gt;子类 父类表达子类), 第二个是向下转型(子类=&gt;父类 子类表达父类)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    peole  lz;</span><br><span class="line">    lz.age = <span class="number">22</span>;</span><br><span class="line">    lz.monry=<span class="number">1</span>;</span><br><span class="line">    animal* anm1=&amp;lz;</span><br><span class="line">    people* humn=(people*)anm1;</span><br><span class="line">    <span class="comment">//不推荐这样用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存切片</strong></p><p>exp: 人类转成动物类的时候, 有些东西会丢掉(比如钱), 这就是内存切片</p><h3 id="对象多态详解"><a href="#对象多态详解" class="headerlink" title="对象多态详解"></a>对象多态详解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">moveobj</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monstermove</span>:</span><span class="keyword">public</span> moveobj</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">monstermove monster;</span><br><span class="line">moveobj* _move=&amp;monster;<span class="comment">//隐式类型转换 向上转型</span></span><br><span class="line"></span><br><span class="line">monstermove* _pmove=&amp;_move; <span class="comment">//隐式 向下转型 不允许!  可以强制</span></span><br><span class="line">monstermove* _pmove=(monstermove*)_move;</span><br><span class="line">monstermove* _pmove=<span class="keyword">static_cast</span>&lt;monstermove*&gt;_move; <span class="comment">//会检测</span></span><br><span class="line">待补充...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="动态强制转换"><a href="#动态强制转换" class="headerlink" title="动态强制转换"></a>动态强制转换</h3><p><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220317_022820.jpg" alt=""></p><p>只能用于多态类</p><h2 id="方法多态-多态类"><a href="#方法多态-多态类" class="headerlink" title="方法多态(多态类)"></a>方法多态(多态类)</h2><p><strong>静态多态</strong></p><p>①函数重载 <code>函数(&amp;类实例化的对象)</code> 从而判断执行哪一个函数</p><p>②函数模板</p><p><strong>动态多态</strong></p><h3 id="virtual虚函数"><a href="#virtual虚函数" class="headerlink" title="virtual虚函数"></a>virtual虚函数</h3><p>告诉派生类 我这个函数是虚的 你需要重写</p><p>virtual 放在定义函数的前面</p><p><strong>使用条件</strong></p><p>virtual只能写在类的内部声明或者定义,不能把virtual写在类的外部定义中</p><p>调用类的对象是无法使用虚函数的,必须使用基类指针来实现虚函数的调用</p><p>虚函数在派生类和基类中必须具有相同的及参数列表</p><p>虚函数在派生类和基类中返回值要求基本一致,但是当返回类型为类类型的指针和引用时除外</p><p>虚函数不能是函数模板</p><p><code>类名* 函数名() override</code> 代表我这个函数是继承来的</p><p>final 代表不再被继承.</p><ul><li><p>虚函数的执行也是遵循类的生成和销毁的(自我理解)</p></li><li><p>可以使用 <code>基类::基类函数()</code> 强行调用基类函数</p></li><li><p>默认实参在基类已经定义了那么派生类的修改是无效的,即使执行派生类的函数</p></li><li>当你通过基类声明派生类对象 <code>基类* p=new 派生类();</code> 然后释放内存调用析构函数的时候,调用的是基类的析构函数(因为派生函数不是虚函数,你是通过基类声明的对象) 容易造成内存泄漏,所以需要 进行 虚析构函数 , 即可正常.</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>在实际的项目设计中,可能出现一种情况,父类有N个派生类<br>比如Animal类派生出Dog和Cat<br>此时我们在Animal类中是无法确定Move函数的内容的,这个时候为Animal类设计Move函数的内容是无意义的,这种情况下我们可以将Move函数设计为纯虚函数<br><code>void virtual Move(=0;</code><br>=0可以将指定的函数设置为纯虚函数</p><p><strong>为什么要定义成纯虚函数</strong> 为了利用它的多态性,实现多态</p><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>有纯虚函数的类 不能用于实体</p><p>拥有纯虚函数的类称为抽象类,因为该类的函数没有实现,因此不能创建抽象类的实例,但是却可以使用抽象类的指针和引用作为返回或者参数!<br>抽象类的构造函数因为不能实际使用,所以一般推荐把抽象类的构造函数定义为protected<br>抽象类的派生类如果没有定义纯虚函数,则该派生类依然是抽象类</p><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p>类中所有(极大部分)函数定义为纯虚函数的类成为接口类</p><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p><code>typeid(类型).name</code></p><p>输出类型名字 但是必须要有多态</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>c++ 的基础还是有些没有总结好,后面补充</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++基础</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.lizheblogs.xyz/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/">https://www.lizheblogs.xyz/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Leechee~</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-03-16</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-04-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E8%8F%9C%E9%B8%A1%E5%AD%A6%E4%B9%A0%E2%9D%80/">菜鸡学习❀</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg" data-sites="qq,wechat,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/13/Ubuntu%E7%BE%8E%E5%8C%96/"><img class="prev-cover" src="https://cdn.lixingyong.com/2022/04/03/img-16446097492911a793c1631d8ef5980bc90243e5cbebd.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubuntu20.04美化</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/16/Acwing/"><img class="next-cover" src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/01/Cplus%E8%A1%A5%E5%85%85/" title="C++基础再学习"><img class="cover" src="https://cdn.lixingyong.com/2022/04/03/img-16446097492911a793c1631d8ef5980bc90243e5cbebd.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">C++基础再学习</div></div></a></div><div><a href="/2022/04/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Linux 网络编程基础"><img class="cover" src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">Linux 网络编程基础</div></div></a></div><div><a href="/2022/04/06/Qt/" title="QT小记"><img class="cover" src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-06</div><div class="title">QT小记</div></div></a></div><div><a href="/2022/02/05/ros%E5%9F%BA%E7%A1%80/" title="ROS1 Noetic"><img class="cover" src="https://cdn.lixingyong.com/2022/03/22/wallhaven-28wqwg_1920x1080.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-05</div><div class="title">ROS1 Noetic</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.lixingyong.com/2022/03/20/nyantocat.gif" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leechee~</div><div class="author-info__description">♥</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn"><i class="fas fa-check"></i><span>收藏一下吧~</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://i0.hdslb.com/bfs/album/3a0f9dd2f82eedafe05022d4c9dacea13efaeb5a.jpg" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/mmqrcode1642538711409.png" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://blog.csdn.net/weixin_45824920?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-csdn"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/zhezheup" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">建设中......<br>由于GitHub仓库丢失以及博客文件(包括文章)的丢失<br>重建需要一定的时间</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80More"><span class="toc-number">1.</span> <span class="toc-text">基础More</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">枚举变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">自定义变量名称</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#array%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">array容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">3.</span> <span class="toc-text">include</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">vector容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-number">4.</span> <span class="toc-text">include</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">5.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">指针数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.2.</span> <span class="toc-text">动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.2.1.</span> <span class="toc-text">c内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.2.2.</span> <span class="toc-text">c++内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%92%8Cnew%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.</span> <span class="toc-text">malloc和new本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free%E5%92%8Cdelete%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.4.</span> <span class="toc-text">free和delete本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%92%8Cdelete-%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.5.</span> <span class="toc-text">delete和delete[]本质区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">5.4.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-unique-ptr"><span class="toc-number">5.4.1.</span> <span class="toc-text">std::unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-shared-ptr"><span class="toc-number">5.4.2.</span> <span class="toc-text">std::shared_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.5.</span> <span class="toc-text">C原生字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93-union"><span class="toc-number">5.6.</span> <span class="toc-text">联合体 union</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="toc-number">5.7.</span> <span class="toc-text">C++字符串string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.7.1.</span> <span class="toc-text">指针数组字符串内存学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.7.2.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">函数参数：右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.2.</span> <span class="toc-text">函数的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">6.3.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.5.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">6.5.1.</span> <span class="toc-text">函数模板和重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B-%E5%A4%9A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.2.</span> <span class="toc-text">推断函数模板返回类型(多不同类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">6.5.3.</span> <span class="toc-text">函数模板参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.5.4.</span> <span class="toc-text">函数模板本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-and-decltype"><span class="toc-number">6.6.</span> <span class="toc-text">auto and decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">6.6.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">6.6.2.</span> <span class="toc-text">decltype</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-only%E5%8F%98%E9%87%8F-and-inline"><span class="toc-number">6.7.</span> <span class="toc-text">static(only变量) and inline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">6.7.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline"><span class="toc-number">6.7.2.</span> <span class="toc-text">inline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern"><span class="toc-number">6.8.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%80%E4%BA%9B%E7%90%86%E8%AE%BA"><span class="toc-number">6.9.</span> <span class="toc-text">函数一些理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">6.9.1.</span> <span class="toc-text">理解定义和声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">6.9.2.</span> <span class="toc-text">头文件和源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84SDK"><span class="toc-number">6.9.3.</span> <span class="toc-text">创建自己的SDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.4.</span> <span class="toc-text">创建项目类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">6.9.5.</span> <span class="toc-text">递归函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">7.1.</span> <span class="toc-text">理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%8D%95%E5%85%83"><span class="toc-number">7.1.1.</span> <span class="toc-text">转换单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.1.2.</span> <span class="toc-text">未定义行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#One-Definition-Rule"><span class="toc-number">7.1.3.</span> <span class="toc-text">One Definition Rule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">7.1.4.</span> <span class="toc-text">名称的链接属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define"><span class="toc-number">7.2.</span> <span class="toc-text">define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">7.3.</span> <span class="toc-text">namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E6%8C%87%E4%BB%A4"><span class="toc-number">7.4.</span> <span class="toc-text">预处理逻辑指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">7.5.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">7.6.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assert%E8%B0%83%E8%AF%95-%EF%BC%88%E6%96%AD%E8%A8%80%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">assert调试 （断言）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">8.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP"><span class="toc-number">9.1.</span> <span class="toc-text">OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">9.1.1.</span> <span class="toc-text">面向对象的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">9.3.1.</span> <span class="toc-text">this指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">9.4.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.5.1.</span> <span class="toc-text">explicit关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">9.5.2.</span> <span class="toc-text">成员初始化列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">9.7.</span> <span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.8.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">9.9.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">9.10.</span> <span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">9.11.</span> <span class="toc-text">类的成员函数的函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3%E7%B1%BB%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89"><span class="toc-number">9.12.</span> <span class="toc-text">从底层理解类（逆向）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">10.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">10.1.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%92%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">10.1.1.</span> <span class="toc-text">原则和时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.2.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.3.</span> <span class="toc-text">重载类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">10.4.</span> <span class="toc-text">重载内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">11.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.</span> <span class="toc-text">继承中的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">继承析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">11.3.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="toc-number">11.4.</span> <span class="toc-text">内存角度理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">12.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81"><span class="toc-number">12.1.</span> <span class="toc-text">对象多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">12.1.1.</span> <span class="toc-text">对象多态详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.1.2.</span> <span class="toc-text">动态强制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%A4%9A%E6%80%81-%E5%A4%9A%E6%80%81%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">方法多态(多态类)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.1.</span> <span class="toc-text">virtual虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.3.1.</span> <span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-1"><span class="toc-number">12.3.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB"><span class="toc-number">12.3.3.</span> <span class="toc-text">接口类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-1"><span class="toc-number">12.4.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/code_linux/" title="我的ubuntu20的vscode设置"><img src="https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="我的ubuntu20的vscode设置"></a><div class="content"><a class="title" href="/2022/04/10/code_linux/" title="我的ubuntu20的vscode设置">我的ubuntu20的vscode设置</a><time datetime="2022-04-10T15:21:13.000Z" title="发表于 2022-04-10 23:21:13">2022-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/06/Qt/" title="QT小记"><img src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="QT小记"></a><div class="content"><a class="title" href="/2022/04/06/Qt/" title="QT小记">QT小记</a><time datetime="2022-04-06T15:21:13.000Z" title="发表于 2022-04-06 23:21:13">2022-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Linux 网络编程基础"><img src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux 网络编程基础"></a><div class="content"><a class="title" href="/2022/04/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Linux 网络编程基础">Linux 网络编程基础</a><time datetime="2022-04-01T15:21:13.000Z" title="发表于 2022-04-01 23:21:13">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/Acwing/" title="算法基础"><img src="https://cdn.lixingyong.com/2022/04/03/e449f2921b1439dfa4cdebce3160f27e.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="算法基础"></a><div class="content"><a class="title" href="/2022/03/16/Acwing/" title="算法基础">算法基础</a><time datetime="2022-03-16T15:21:13.000Z" title="发表于 2022-03-16 23:21:13">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/" title="C++基础"><img src="https://cdn.lixingyong.com/2022/04/18/1641179292631_05TKS.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="C++基础"></a><div class="content"><a class="title" href="/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/" title="C++基础">C++基础</a><time datetime="2022-03-16T15:21:13.000Z" title="发表于 2022-03-16 23:21:13">2022-03-16</time></div></div></div></div></div></div></main><footer id="footer" style="background:linear-gradient(135deg,"><div id="footer-wrap"><div class="copyright"><span>&copy;2021 - 2022</span><svg style="width:1.5em;height:1.5em" aria-hidden="true"><use xlink:href="#icon-butterfly"></use></svg><span>Leechee~</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="sakura_show" type="button" title="打开/关闭-❀樱花"><i class="fas fa-candy-cane"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="在线聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),4e3)</script><div class="js-pjax"><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(e.length){window.runMermaid=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,i="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent;mermaid.mermaidAPI.render(r,i,e=>{d.insertAdjacentHTML("afterend",e)})})};const t=()=>{window.loadMermaid?runMermaid():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(runMermaid)};window.pjax?t():document.addEventListener("DOMContentLoaded",t)}})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-phi-lime.vercel.app/",region:"ap-xian-ec",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.vemoji)"))}},null))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script><script>function loadDisqus(){var e,s,t=function(){this.page.url="https://www.lizheblogs.xyz/2022/03/16/Cplus%E5%9F%BA%E7%A1%80/",this.page.identifier="2022/03/16/Cplus基础/",this.page.title="C++基础"};window.disqusReset=()=>{DISQUS.reset({reload:!0,config:t})},window.DISQUS?disqusReset():(e=document,(s=e.createElement("script")).src="https://disqus_el5qs5OXyM.disqus.com/embed.js",s.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(s))}{function loadOtherComment(){loadDisqus()}loadDisqus()}</script></div><script data-pjax defer src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/js/circleMagic.min.js"></script><script data-pjax async src="/js/diytitle.js"></script><script data-pjax async src="//at.alicdn.com/t/font_3162155_rj0cwkyfph.js"></script><script data-pjax async src="//at.alicdn.com/t/font_3384182_5m6hdp0p0yw.js"></script><script defer src="https://gcore.jsdelivr.net/gh/PipecraftNet/jsdelivr-auto-fallback@main/index.min.js"></script><script src="//code.tidio.co/pdpo6idc0mzvfbbiob4uihzuk4wuryvn.js" async></script><script>function onTidioChatApiReady(){window.tidioChatApi.hide(),window.tidioChatApi.on("close",(function(){window.tidioChatApi.hide()}))}window.tidioChatApi?window.tidioChatApi.on("ready",onTidioChatApiReady):document.addEventListener("tidioChat-ready",onTidioChatApiReady);var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",(function(){window.tidioChatApi.show(),window.tidioChatApi.open()}))};chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/01/10/Normal Tips/" alt=""><img width="48" height="48" src="https://cdn.lixingyong.com/2022/03/22/wallhaven-28wqwg_1920x1080.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-10</span><a class="blog-slider__title" href="2022/01/10/Normal Tips/" alt="">学习途中小Tips</a><div class="blog-slider__text">百宝箱来喽~</div><a class="blog-slider__button" href="2022/01/10/Normal Tips/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/01/01/文章Tips/" alt=""><img width="48" height="48" src="https://cdn.lixingyong.com/2022/04/03/zcool.jfif.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-01</span><a class="blog-slider__title" href="2022/01/01/文章Tips/" alt="">博客常用配置</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2022/01/01/文章Tips/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>function butterfly_clock_injector_config(){var l=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock"),l.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_injector_config()</script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),e.insertAdjacentHTML("beforeend",'<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" title="本站已在工信部备案，备案号：陕ICP备2021012694号-1"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/陕ICP备-2021012694号-A5915F.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/CDN-jsDelivr-orange.svg" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" title="本站由又拍云提供CDN加速服务"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/CDN加速-又拍云-00CAFF.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/Source-Github-d021d6.svg" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/Copyright-BY--NC--SA 4.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.lizheblogs.xyz/" style="margin-inline:5px" title="本战由瑶瑶同学和哲哲同学运营♥"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/哲哲和瑶瑶の小屋-正在营业-F02E65.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://dash.cloudflare.com/" style="margin-inline:5px" title="本站整体由CLOUDFLARE托管并提供防护"><img src="https://npm.elemecdn.com/lz-assets@0.0.3/image/Hosted And Protect BY-CLOUDFLARE-F38020.svg" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script async src="https://npm.elemecdn.com/lz-assets@0.0.3/js/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("recent-posts").insertAdjacentHTML("afterbegin",'<container><style>#git_container{min-height: 290px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:3%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></container>'),console.log("已挂载gitcalendar")}document.getElementById("recent-posts")&&"/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("https://gitcalendar.akilar.top/api?zhezheup",["#e4dfd7","#f9f4dc","#f7e8aa","#f7e8aa","#f8df72","#fcd217","#fcc515","#f28e16","#fb8b05","#d85916","#f43e06"],"zhezheup"))</script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>